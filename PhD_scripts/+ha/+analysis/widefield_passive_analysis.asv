% Passive widefield analysis


%% Load variables and define colours

load("C:\Users\havgana\Desktop\DPhil\packaged_data\passive_data_all_animals_14_01_26.mat"); % wf passive
load('C:\Users\havgana\Desktop\DPhil\packaged_data\behaviour_structure_all_animals_14_01_26.mat') % behaviour
load('C:\Users\havgana\Desktop\DPhil\packaged_data\combined_sig_day_all_protocols_14_01_26.mat') % sig days


% load master_U
wf_U= plab.wf.load_master_U;

added_time = -0.5:0.03:1; % for passive

% ROI masks
mPFC_data = load('C:\Users\havgana\Desktop\DPhil\Coding Scripts\ROIs\mPFC_ROI.mat');
left_mPFC_ROI_mask = mPFC_data.new_pfc_roi_mask;
right_mPFC_ROI_mask = fliplr(left_mPFC_ROI_mask);

ViS_ROI_data = load("C:\Users\havgana\Desktop\DPhil\Coding Scripts\ROIs\right_ViS_mask.mat");
left_ViS_ROI_mask = ViS_ROI_data.visual_cortex_mask;
right_ViS_ROI_mask = fliplr(left_ViS_ROI_mask);


% set up two custom colors for learners and non-learners
cmPFC_plus   = [0 0.6 0];   % dark green
cmPFC_minus = [0.6 0 0.6]; % purple

%% Given that HA009 have two recordings in which lcr_passive reguglar size is missing, it requires some padding

% Get all the widefield data
widefield_cat = cat(2, passive_data.widefield);

% Extract and pad different variables

right_stim_v_stacked_data = ha.helper_func.pad_widefield_variable(widefield_cat, 'right_stim_aligned_V');
left_stim_v_stacked_data = ha.helper_func.pad_widefield_variable(widefield_cat, 'left_stim_aligned_V');
center_stim_v_stacked_data = ha.helper_func.pad_widefield_variable(widefield_cat, 'center_stim_aligned_V', false); % silent mode

right_stim_kernel = ha.helper_func.pad_widefield_variable(widefield_cat, 'right_stim_aligned_kernel');
left_stim_kernel = ha.helper_func.pad_widefield_variable(widefield_cat, 'left_stim_aligned_kernel');
center_stim_kernel = ha.helper_func.pad_widefield_variable(widefield_cat, 'center_stim_aligned_kernel');

% % Verify dimensions match
% fprintf('\nWorkflow index: %d days\n', length(workflow_cat));
% fprintf('Learning index: %d days\n', length(learning_index_animal));
% fprintf('Animal index: %d days\n', length(widefield_animal_idx));


%% Set up variables

% only using n components
n_components=200;
n_components_kernel= 100;

% make protocol index (n all days x workflow number ordered)
workflow_animal = cellfun(@(x) {x.workflow},{behaviour_data.recording_day},'uni',false);
workflow_cat = grp2idx(horzcat(workflow_animal{:}));

% Create a logical learning index variable (n all days x [0,1])
learning_index_animal = vertcat(combined_sig_day_all_protocols{:});

% Creates an animal index (n all days x animal number ordered)
widefield_animal_idx = grp2idx(cell2mat(cellfun(@(animal,wf) repmat(animal,length(wf),1), ...
    {behaviour_data.animal_id},{passive_data.widefield},'uni',false)'));


% Group data by animal x protocol x learning day
[right_stim_V_learn_avg,right_stim_V_learn_grp] = ...
    ap.nestgroupfun({@nanmean,@nanmean,@nanmean}, permute(right_stim_v_stacked_data,[3,1,2]), ...
    [] ,[widefield_animal_idx,workflow_cat,learning_index_animal]);


[center_stim_V_learn_avg,center_stim_V_learn_grp] = ...
    ap.nestgroupfun({@nanmean,@nanmean,@nanmean}, permute(center_stim_v_stacked_data,[3,1,2]), ...
    [] ,[widefield_animal_idx,workflow_cat,learning_index_animal]);

% Create labels for plotting

animal_list= {behaviour_data.animal_id}; % get animal list
unique_workflow_labels= unique(horzcat(workflow_animal{:}),"stable"); % unique workflows by order


%% Plot line variables setup

% define event times
event_times= [-0.5,0.75];
baseline_time_windows = [-0.1, 0];

% data to index:  V×T×Ndays_total
aligned_all = center_stim_v_stacked_data;

% define the added time 
added_time_V= added_time;
added_time_Kernel= fliplr((-10:30)/30);

% Find the corresponding indices in added_time for the time window
time_window_idx = find(added_time_V >= event_times(1) & added_time_V <= event_times(2));
baseline_mask_idx = (added_time_V >= baseline_time_windows(1) & added_time_V <= baseline_time_windows(2));

% % 1×T win vector in seconds
t_for_plot = added_time_V(time_window_idx);


% right mPFC
right_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,time_window_idx,:),[],[], right_mPFC_ROI_mask), ...
    [3,2,1] );   % gives Ndays_total × T

right_mPFC_ROI_baseline=permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,baseline_mask_idx,:),[],[], right_mPFC_ROI_mask), ...
    [3,2,1] );   % gives Ndays_total × T

right_mPFC_ROI_trace= right_mPFC_ROI_trace- mean(right_mPFC_ROI_baseline,2);

% left mPFC
left_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,time_window_idx,:),[],[], left_mPFC_ROI_mask), ...
    [3,2,1] );   % same dims

left_mPFC_ROI_baseline=permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,baseline_mask_idx,:),[],[], left_mPFC_ROI_mask), ...
    [3,2,1] );   % gives Ndays_total × T

left_mPFC_ROI_trace= left_mPFC_ROI_trace- mean(left_mPFC_ROI_baseline,2);

% For visual cortex
right_ViS_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,time_window_idx,:),[],[], right_ViS_ROI_mask), ...
    [3,2,1] );   % gives Ndays_total × T

left_ViS_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,time_window_idx,:),[],[], left_ViS_ROI_mask), ...
    [3,2,1] );   % gives Ndays_total × T



%% Explorartory : Plot mPFC responses split mPFC+/mPFC- pre-post learning 

% Is there an mPFC reponse difference between those who learned static and
% those who didn't for right and centre stimulus?

% animals that have not learned the static but learned the right
group_animals = {'DS017','HA006','HA007','HA009','HA013','HA014','HA015','AP030','AP031','AP032'};

is_group_animal= ismember(animal_list(widefield_animal_idx), group_animals)';

% pre post of workflow 3 (right move)
pre = nanmean(center_stim_v_stacked_data(:,:,workflow_cat==1 & learning_index_animal==0 & is_group_animal==0 ),3);
post = nanmean(center_stim_v_stacked_data(:,:,workflow_cat==1 & learning_index_animal==1 & is_group_animal==0),3);

baseline_start= [-0.1,0];
baseline_mask= find(added_time >baseline_start(1) & added_time<baseline_start(2));

% substract baseline
pre_baseline_sub= pre- mean(pre(:,baseline_mask),2);
post_baseline_sub= post- mean(post(:,baseline_mask),2);

ap.imscroll([plab.wf.svd2px(wf_U(:,:,1:n_components),pre_baseline_sub),plab.wf.svd2px(wf_U(:,:,1:n_components),post_baseline_sub)]);
clim([-max(abs(clim)), max(abs(clim))]);
colormap(ap.colormap( ...
    'PWG'));
axis image;

%% Plot CCF videos of individual animals

animal_list;

% pre post of workflow 3 (right move)
pre = nanmean(center_stim_v_stacked_data(:,:,workflow_cat==1 & learning_index_animal==0 & widefield_animal_idx==7),3);
post = nanmean(center_stim_v_stacked_data(:,:,workflow_cat==1 & learning_index_animal==1 & widefield_animal_idx==7),3);

added_time_Kernel=  fliplr((-10:30)/30);

baseline_time_windows= [-0.1,0];
baseline_mask = (added_time>= baseline_time_windows(1)) & (added_time <= baseline_time_windows(2));


% substract baseline
pre_baseline_sub= pre- mean(pre(:,baseline_mask),2);
post_baseline_sub= post- mean(post(:,baseline_mask),2);

ap.imscroll([plab.wf.svd2px(wf_U(:,:,1:n_components),pre_baseline_sub),plab.wf.svd2px(wf_U(:,:,1:n_components),post_baseline_sub)],added_time);
clim([-max(abs(clim)), max(abs(clim))]);
colormap(ap.colormap( ...
    'PWG'));
axis image;


%% Plot baseline corrected CCF average/max of mPFC activity (V) for each individual animal pre-post learning

% Choose 'max' or 'mean' to plot
statistic = 'max';

% Define event and baseline time windows
event_times = [0, 0.3];
baseline_time_windows = [-0.1, 0];

% Create logical masks for both
event_time_window_mask = (added_time > event_times(1) & added_time < event_times(2));
baseline_mask = (added_time >= baseline_time_windows(1) & added_time <= baseline_time_windows(2));

% Define data to plot
data_to_plot = right_stim_kernel;

% Define protocol
protocol_idx = 2;

% Define colors
cmPFC_plus = [0.3, 0.6, 0.3];      % Green for learners
cNonlearner = [0.8, 0.3, 0.3];   % Red for non-learners

% Get unique animals
animals = unique(widefield_animal_idx);

% Determine global color limit across all animals
all_timewindow_data = [];

for ai = animals(:)'
    % Get pre and post learning data for this animal
    pre_data = data_to_plot(:, :, workflow_cat == protocol_idx & learning_index_animal == 0 & widefield_animal_idx == ai);
    post_data = data_to_plot(:, :, workflow_cat == protocol_idx & learning_index_animal == 1 & widefield_animal_idx == ai);
    
    if isempty(pre_data) && isempty(post_data), continue; end
    
    % Average across days
    mean_pre = nanmean(pre_data, 3);
    mean_post = nanmean(post_data, 3);
    
    % Baseline subtract
    if ~isempty(pre_data)
        baseline_sub_pre = mean_pre - nanmean(mean_pre(:, baseline_mask), 2);
        timewindow_pre = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_pre(:, event_time_window_mask));
        all_timewindow_data = [all_timewindow_data; timewindow_pre(:)];
    end
    
    if ~isempty(post_data)
        baseline_sub_post = mean_post - nanmean(mean_post(:, baseline_mask), 2);
        timewindow_post = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_post(:, event_time_window_mask));
        all_timewindow_data = [all_timewindow_data; timewindow_post(:)];
    end
end

% Compute global color limit
switch statistic
    case 'max'
        clim_val = 0.5 * max(abs(all_timewindow_data));
    case 'mean'
        clim_val = 0.5 * max(abs(all_timewindow_data));
end

% Loop through each animal and plot
for ai = animals(:)'
    % Check if this animal is a learner or non-learner
    animal_days = widefield_animal_idx == ai;
    is_learner = ~is_group_animal(find(animal_days, 1, 'first')); % Get learner status
    
    % Set color based on group
    if is_learner
        animal_color = cmPFC_plus;
        group_label = 'mPFC+';
    else
        animal_color = cNonlearner;
        group_label = 'mPFC-';
    end
    
    % Get pre and post learning data for this animal
    pre_mask = workflow_cat == protocol_idx & learning_index_animal == 0 & widefield_animal_idx == ai;
    post_mask = workflow_cat == protocol_idx & learning_index_animal == 1 & widefield_animal_idx == ai;
    
    pre_data = data_to_plot(:, :, pre_mask);
    post_data = data_to_plot(:, :, post_mask);
    
    % Skip if no data
    if isempty(pre_data) && isempty(post_data)
        fprintf('No data for animal %d\n', ai);
        continue;
    end
    
    % Average across days
    mean_pre = nanmean(pre_data, 3);
    mean_post = nanmean(post_data, 3);
    
    % Baseline subtract
    baseline_sub_pre = mean_pre - nanmean(mean_pre(:, baseline_mask), 2);
    baseline_sub_post = mean_post - nanmean(mean_post(:, baseline_mask), 2);
    
    % Get specific time window
    timewindow_pre = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_pre(:, event_time_window_mask));
    timewindow_post = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_post(:, event_time_window_mask));
    
    % Compute images
    switch statistic
        case 'max'
            img_pre = max(timewindow_pre, [], 3);
            img_post = max(timewindow_post, [], 3);
        case 'mean'
            img_pre = mean(timewindow_pre, 3);
            img_post = mean(timewindow_post, 3);
    end
    
    % Create figure with subplots
    figure('Position', [100, 100, 1200, 500]);
    
    % Pre-learning
    subplot(1, 2, 1);
    imagesc(img_pre);
    axis image off;
    colormap(ap.colormap('PWG'));
    clim([-clim_val, clim_val]);
    title(sprintf('Animal %d Pre-Learning - %s', ai, group_label), 'Color', animal_color, 'FontWeight', 'bold');
    ap.wf_draw('ccf');
    
    % Post-learning
    subplot(1, 2, 2);
    imagesc(img_post);
    axis image off;
    colormap(ap.colormap('PWG'));
    clim([-clim_val, clim_val]);
    title(sprintf('Animal %d Post-Learning - %s', ai, group_label), 'Color', animal_color, 'FontWeight', 'bold');
    ap.wf_draw('ccf');
    
    % Overall figure title
    sgtitle(sprintf('Animal %d: %s (%s)', ai, statistic, group_label), 'FontSize', 14, 'FontWeight', 'bold');
end

%% Plot baseline corrected CCF average/max of mPFC activity (Kernels) for each individual animal pre-post learning

% Choose 'max' or 'mean' to plot
statistic = 'max';

% Define event and baseline time windows
event_times = [0, 0.3];
baseline_time_windows = [-0.1, 0];

% Create logical masks for both
event_time_window_mask = (added_time_Kernel > event_times(1) & added_time_Kernel < event_times(2));
baseline_mask = (added_time_Kernel >= baseline_time_windows(1) & added_time_Kernel <= baseline_time_windows(2));

% Define data to plot
data_to_plot = right_stim_kernel;

% Define protocol
protocol_idx = 1;

% Define colors
cmPFC_plus = [0.3, 0.6, 0.3];      % Green for learners
cNonlearner = [0.8, 0.3, 0.3];   % Red for non-learners

% Get unique animals
animals = unique(widefield_animal_idx);

% Determine global color limit across all animals
all_timewindow_data = [];

for ai = animals(:)'
    % Get pre and post learning data for this animal
    pre_data = data_to_plot(:, :, workflow_cat == protocol_idx & learning_index_animal == 0 & widefield_animal_idx == ai);
    post_data = data_to_plot(:, :, workflow_cat == protocol_idx & learning_index_animal == 1 & widefield_animal_idx == ai);
    
    if isempty(pre_data) && isempty(post_data), continue; end
    
    % Average across days
    mean_pre = nanmean(pre_data, 3);
    mean_post = nanmean(post_data, 3);
    
    % Baseline subtract
    if ~isempty(pre_data)
        baseline_sub_pre = mean_pre - nanmean(mean_pre(:, baseline_mask), 2);
        timewindow_pre = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_pre(:, event_time_window_mask));
        all_timewindow_data = [all_timewindow_data; timewindow_pre(:)];
    end
    
    if ~isempty(post_data)
        baseline_sub_post = mean_post - nanmean(mean_post(:, baseline_mask), 2);
        timewindow_post = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_post(:, event_time_window_mask));
        all_timewindow_data = [all_timewindow_data; timewindow_post(:)];
    end
end

% Compute global color limit
switch statistic
    case 'max'
        clim_val = 0.25 * max(abs(all_timewindow_data));
    case 'mean'
        clim_val = 0.5 * max(abs(all_timewindow_data));
end

% Loop through each animal and plot
for ai = animals(:)'
    % Check if this animal is a learner or non-learner
    animal_days = widefield_animal_idx == ai;
    is_learner = ~is_group_animal(find(animal_days, 1, 'first')); % Get learner status
    
    % Set color based on group
    if is_learner
        animal_color = cmPFC_plus;
        group_label = 'mPFC+';
    else
        animal_color = cNonlearner;
        group_label = 'mPFC-';
    end
    
    % Get pre and post learning data for this animal
    pre_mask = workflow_cat == protocol_idx & learning_index_animal == 0 & widefield_animal_idx == ai;
    post_mask = workflow_cat == protocol_idx & learning_index_animal == 1 & widefield_animal_idx == ai;
    
    pre_data = data_to_plot(:, :, pre_mask);
    post_data = data_to_plot(:, :, post_mask);
    
    % Skip if no data
    if isempty(pre_data) && isempty(post_data)
        fprintf('No data for animal %d\n', ai);
        continue;
    end
    
    % Average across days
    mean_pre = nanmean(pre_data, 3);
    mean_post = nanmean(post_data, 3);
    
    % Baseline subtract
    baseline_sub_pre = mean_pre - nanmean(mean_pre(:, baseline_mask), 2);
    baseline_sub_post = mean_post - nanmean(mean_post(:, baseline_mask), 2);
    
    % Get specific time window
    timewindow_pre = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_pre(:, event_time_window_mask));
    timewindow_post = plab.wf.svd2px(wf_U(:, :, 1:n_components), baseline_sub_post(:, event_time_window_mask));
    
    % Compute images
    switch statistic
        case 'max'
            img_pre = max(timewindow_pre, [], 3);
            img_post = max(timewindow_post, [], 3);
        case 'mean'
            img_pre = mean(timewindow_pre, 3);
            img_post = mean(timewindow_post, 3);
    end
    
    % Create figure with subplots
    figure('Position', [100, 100, 1200, 500]);
    
    % Pre-learning
    subplot(1, 2, 1);
    imagesc(img_pre);
    axis image off;
    colormap(ap.colormap('PWG'));
    clim([-clim_val, clim_val]);
    title(sprintf('Animal %d Pre-Learning - %s', ai, group_label), 'Color', animal_color, 'FontWeight', 'bold');
    ap.wf_draw('ccf');
    
    % Post-learning
    subplot(1, 2, 2);
    imagesc(img_post);
    axis image off;
    colormap(ap.colormap('PWG'));
    clim([-clim_val, clim_val]);
    title(sprintf('Animal %d Post-Learning - %s', ai, group_label), 'Color', animal_color, 'FontWeight', 'bold');
    ap.wf_draw('ccf');
    
    % Overall figure title
    sgtitle(sprintf('Animal %d: %s (%s)', ai, statistic, group_label), 'FontSize', 14, 'FontWeight', 'bold');
end

%% Plot mPFC ROI of mPFC+ and mPFC- groups with individual animal lines and mean

% Define which ROI to plot (change as needed)
ROI_trace = left_mPFC_ROI_trace; % or left_mPFC_ROI_trace, right_ViS_ROI_trace, etc.
ROI_name = 'left mPFC';

% Define protocol
protocol_idx = 1;

% Get unique animals
animals = unique(widefield_animal_idx);

% Define maximum days before/after learning to include
max_days_before = 10;
max_days_after = 10;

% Storage for aligned data
learner_data = cell(length(animals), 1);
nonlearner_data = cell(length(animals), 1);
learner_counter = 0;
nonlearner_counter = 0;

% Align each animal's data to their learning day
for ai = animals(:)'
    % Get days for this animal in the protocol
    animal_mask = (widefield_animal_idx == ai) & (workflow_cat == protocol_idx);
    animal_days = find(animal_mask);
    
    if isempty(animal_days), continue; end
    
    % Find learning day for this animal
    learning_days_local = learning_index_animal(animal_days);
    first_learning_idx = find(learning_days_local == 1, 1, 'first');
    
    if isempty(first_learning_idx)
        % n_days = length(animal_days);
        % first_learning_idx=n_days+1; % define all days as pre
        continue;
    end
    
    % Create relative day indices (0 = learning day)
    n_days = length(animal_days);
    relative_days = (1:n_days) - first_learning_idx;
    
    % Get ROI traces for this animal
    animal_traces = ROI_trace(animal_days, :); % n_days × T
    
    % Store aligned data with relative day indices
    aligned_animal_data = struct();
    aligned_animal_data.relative_days = relative_days;
    aligned_animal_data.traces = animal_traces;
    aligned_animal_data.animal_id = ai;
    
    % Determine if learner or non-learner
    is_learner = ~is_group_animal(animal_days(1));
    
    if is_learner
        learner_counter = learner_counter + 1;
        learner_data{learner_counter} = aligned_animal_data;
    else
        nonlearner_counter = nonlearner_counter + 1;
        nonlearner_data{nonlearner_counter} = aligned_animal_data;
    end
end

% Trim storage
learner_data = learner_data(1:learner_counter);
nonlearner_data = nonlearner_data(1:nonlearner_counter);


% define response window
response_window = t_for_plot >= 0 & t_for_plot <= 0.3;

% Process learners
learner_aligned_days = -max_days_before:max_days_after;
learner_aligned_activity = nan(length(learner_data), length(learner_aligned_days));

for i = 1:length(learner_data)
    animal_rel_days = learner_data{i}.relative_days;
    animal_activity = ha.helper_func.compute_activity(learner_data{i}.traces, response_window);
    
    % Map to aligned day array
    for d = 1:length(animal_rel_days)
        rel_day = animal_rel_days(d);
        aligned_idx = find(learner_aligned_days == rel_day, 1);
        if ~isempty(aligned_idx)
            learner_aligned_activity(i, aligned_idx) = animal_activity(d);
        end
    end
end

% Process non-learners
nonlearner_aligned_days = -max_days_before:max_days_after;
nonlearner_aligned_activity = nan(length(nonlearner_data), length(nonlearner_aligned_days));

for i = 1:length(nonlearner_data)
    animal_rel_days = nonlearner_data{i}.relative_days;
    animal_activity = ha.helper_func.compute_activity(nonlearner_data{i}.traces, response_window);
    
    % Map to aligned day array
    for d = 1:length(animal_rel_days)
        rel_day = animal_rel_days(d);
        aligned_idx = find(nonlearner_aligned_days == rel_day, 1);
        if ~isempty(aligned_idx)
            nonlearner_aligned_activity(i, aligned_idx) = animal_activity(d);
        end
    end
end

% Plot Learners (mPFC+)
figure('Position', [100, 100, 1000, 500]);

subplot(1, 2, 1);
hold on;

% Plot individual animals
for i = 1:size(learner_aligned_activity, 1)
    plot(learner_aligned_days, learner_aligned_activity(i, :), '-', ...
         'Color', [cmPFC_plus, 0.3], 'LineWidth', 1);
end

% Compute and plot group mean ± SEM
group_mean = nanmean(learner_aligned_activity, 1);
group_sem = nanstd(learner_aligned_activity, 0, 1) / sqrt(sum(~isnan(learner_aligned_activity), 1));

% Plot mean
plot(learner_aligned_days, group_mean, '-', 'Color', cmPFC_plus, 'LineWidth', 3);

% Plot SEM shading
fill([learner_aligned_days, fliplr(learner_aligned_days)], ...
     [group_mean + group_sem, fliplr(group_mean - group_sem)], ...
     cmPFC_plus, 'FaceAlpha', 0.3, 'EdgeColor', 'none');

% Mark learning day
xline(0, '--k', 'Learning Day', 'LineWidth', 2, 'FontSize', 10, 'FontWeight', 'bold');

xlabel('Days Relative to Learning', 'FontSize', 12, 'FontWeight', 'bold');
ylabel('Peak Activity', 'FontSize', 12, 'FontWeight', 'bold');
title(sprintf('mPFC+ Animals (n=%d)', length(learner_data)), 'FontSize', 13, 'FontWeight', 'bold');
xlim([-max_days_before, max_days_after]);
set(gca, 'FontSize', 11);
grid on;
hold off;

% Plot Non-Learners (mPFC-)
subplot(1, 2, 2);
hold on;

% Plot individual animals
for i = 1:size(nonlearner_aligned_activity, 1)
    plot(nonlearner_aligned_days, nonlearner_aligned_activity(i, :), '-', ...
         'Color', [cmPFC_minus, 0.3], 'LineWidth', 1);
end

% Compute and plot group mean ± SEM
group_mean = nanmean(nonlearner_aligned_activity, 1);
group_sem = nanstd(nonlearner_aligned_activity, 0, 1) / sqrt(sum(~isnan(nonlearner_aligned_activity), 1));

% Plot mean
plot(nonlearner_aligned_days, group_mean, '-', 'Color', cmPFC_minus, 'LineWidth', 3);

% Plot SEM shading
fill([nonlearner_aligned_days, fliplr(nonlearner_aligned_days)], ...
     [group_mean + group_sem, fliplr(group_mean - group_sem)], ...
     cmPFC_minus, 'FaceAlpha', 0.3, 'EdgeColor', 'none');

% Mark learning day
xline(0, '--k', 'Learning Day', 'LineWidth', 2, 'FontSize', 10, 'FontWeight', 'bold');

xlabel('Days Relative to Learning', 'FontSize', 12, 'FontWeight', 'bold');
ylabel('Peak Activity', 'FontSize', 12, 'FontWeight', 'bold');
title(sprintf('mPFC- Animals (n=%d)', length(nonlearner_data)), 'FontSize', 13, 'FontWeight', 'bold');
xlim([-max_days_before, max_days_after]);
set(gca, 'FontSize', 11);
grid on;
hold off;

sgtitle(sprintf('%s Kernel Activity Aligned to Learning Day (Right Stim)', ROI_name), ...
        'FontSize', 14, 'FontWeight', 'bold');

%% Plot baseline corrected CCF average/max mPFC activity (V) comparing learners vs non-learners

% Choose 'max' or 'mean' to plot
statistic = 'max';

% Define event and baseline time windows
event_times = [0, 0.3];
baseline_time_windows = [-0.1, 0];

% Create logical masks for both
event_time_window_mask = (added_time > event_times(1) & added_time < event_times(2));
baseline_mask = (added_time >= baseline_time_windows(1) & added_time <= baseline_time_windows(2));

% define data to plot
data_to_plot= right_stim_v_stacked_data;

% define protocol
protocol_idx=1;

% pre post of right move workflow split by learning days and learners vs
% non-learners
mean_pre_learning_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==0 & is_group_animal==0 ),3);
mean_post_learning_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==1 & is_group_animal==0),3);

mean_pre_learning_non_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==0 & is_group_animal==1 ),3);
mean_post_learning_non_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==1 & is_group_animal==1),3);

% substract baseline
baseline_substracted_pre_learning_LR= mean_pre_learning_learners- nanmean(mean_pre_learning_learners(:,baseline_mask),2);
baseline_substracted_post_learning_LR= mean_post_learning_learners- nanmean(mean_post_learning_learners(:,baseline_mask),2);

baseline_substracted_pre_learning_NLR= mean_pre_learning_non_learners- nanmean(mean_pre_learning_non_learners(:,baseline_mask),2);
baseline_substracted_post_learning_NLR= mean_post_learning_non_learners- nanmean(mean_post_learning_non_learners(:,baseline_mask),2);

% get the specific time window
timewindow_mean_pre_learning_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_pre_learning_LR(:,event_time_window_mask));
timewindow_mean_post_learning_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_post_learning_LR(:,event_time_window_mask));

timewindow_mean_pre_learning_non_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_pre_learning_NLR(:,event_time_window_mask));
timewindow_mean_post_learning_non_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_post_learning_NLR(:,event_time_window_mask));



% Compute the image to show
switch statistic
    case 'max'
        img_pre_learning_learners = max(timewindow_mean_pre_learning_learners, [], 3);
        img_post_learning_learners= max(timewindow_mean_post_learning_learners, [], 3);
        img_pre_learning_non_learners   = max(timewindow_mean_pre_learning_non_learners, [], 3);
        img_post_learning_non_learners   = max(timewindow_mean_post_learning_non_learners, [], 3);

    case 'mean'
        img_pre_learning_learners = mean(timewindow_mean_pre_learning_learners, 3);
        img_post_learning_learners= mean(timewindow_mean_post_learning_learners, 3);
        img_pre_learning_non_learners = mean(timewindow_mean_pre_learning_non_learners, 3);
        img_post_learning_non_learners = mean(timewindow_mean_post_learning_non_learners,3);

    otherwise
        error('statistic must be ''max'' or ''mean''');
end

% Compute a common color‐limit
all_vals = [timewindow_mean_pre_learning_learners(:); timewindow_mean_pre_learning_non_learners(:)];
switch statistic
    case 'max'
        ref_vals = max(reshape(all_vals,[],size(timewindow_mean_pre_learning_learners,3)),[],2);
    case 'mean'
        ref_vals = mean(reshape(all_vals,[],size(timewindow_mean_pre_learning_learners,3)),2);
end
clim_val = 0.5 * max(abs(ref_vals));

% clim_holder= clim;
% clim_val=clim_holder(2);

% Plot learners
figure;
imagesc(img_pre_learning_learners);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title(sprintf('Pre-Learning %s V activity — Learners', statistic));
ap.wf_draw('ccf');

figure;
imagesc(img_post_learning_learners);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title(sprintf('Post-Learning %s V activity — Learners', statistic));
ap.wf_draw('ccf');

% Plot non learners
figure;
imagesc(img_pre_learning_non_learners);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title(sprintf('Pre-Learning %s V activity — Non-learners', statistic));
ap.wf_draw('ccf');

figure;
imagesc(img_post_learning_non_learners);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title(sprintf('Post-Learning %s V activity — Non-learners', statistic));
ap.wf_draw('ccf');


%% Plot CCF average/max mPFC activity (Kernels) comparing learners vs non-learners


% Choose 'max' or 'mean' to plot
statistic = 'max';

% define data to plot
data_to_plot= right_stim_kernel;

% define protocol
protocol_idx=1;

added_time_Kernel=  fliplr((-10:30)/30);

% Create logical masks for both
event_time_window_mask = (added_time_Kernel > event_times(1) & added_time_Kernel < event_times(2));
baseline_mask = (added_time_Kernel >= baseline_time_windows(1) & added_time_Kernel <= baseline_time_windows(2));


% pre post of right move workflow split by learning days and learners vs
% non-learners

mean_pre_learning_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==0 & is_group_animal==0 ),3);
mean_post_learning_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==1 & is_group_animal==0),3);

mean_pre_learning_non_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==0 & is_group_animal==1 ),3);
mean_post_learning_non_learners = nanmean(data_to_plot(:,:,workflow_cat==protocol_idx & learning_index_animal==1 & is_group_animal==1),3);

% substract baseline
baseline_substracted_pre_learning_LR= mean_pre_learning_learners- nanmean(mean_pre_learning_learners(:,baseline_mask),2);
baseline_substracted_post_learning_LR= mean_post_learning_learners- nanmean(mean_post_learning_learners(:,baseline_mask),2);

baseline_substracted_pre_learning_NLR= mean_pre_learning_non_learners- nanmean(mean_pre_learning_non_learners(:,baseline_mask),2);
baseline_substracted_post_learning_NLR= mean_post_learning_non_learners- nanmean(mean_post_learning_non_learners(:,baseline_mask),2);

% get the specific time window
timewindow_mean_pre_learning_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_pre_learning_LR(:,event_time_window_mask));
timewindow_mean_post_learning_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_post_learning_LR(:,event_time_window_mask));

timewindow_mean_pre_learning_non_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_pre_learning_NLR(:,event_time_window_mask));
timewindow_mean_post_learning_non_learners= plab.wf.svd2px(wf_U(:,:,1:n_components), baseline_substracted_post_learning_NLR(:,event_time_window_mask));


% Compute the image to show
switch statistic
    case 'max'
        img_pre_learning_learners = max(timewindow_mean_pre_learning_learners, [], 3);
        img_post_learning_learners= max(timewindow_mean_post_learning_learners, [], 3);
        img_pre_learning_non_learners   = max(timewindow_mean_pre_learning_non_learners, [], 3);
        img_post_learning_non_learners   = max(timewindow_mean_post_learning_non_learners, [], 3);

    case 'mean'
        img_pre_learning_learners = mean(timewindow_mean_pre_learning_learners, 3);
        img_post_learning_learners= mean(timewindow_mean_post_learning_learners, 3);
        img_pre_learning_non_learners = mean(timewindow_mean_pre_learning_non_learners, 3);
        img_post_learning_non_learners = mean(timewindow_mean_post_learning_non_learners,3);

    otherwise
        error('statistic must be ''max'' or ''mean''');
end

% Compute a common color‐limit
all_vals = [timewindow_mean_pre_learning_learners(:); timewindow_mean_pre_learning_non_learners(:)];
switch statistic
    case 'max'
        ref_vals = max(reshape(all_vals,[],size(timewindow_mean_pre_learning_learners,3)),[],2);
    case 'mean'
        ref_vals = mean(reshape(all_vals,[],size(timewindow_mean_pre_learning_learners,3)),2);
end
clim_val = 0.35* max(abs(ref_vals));

% For creating a colorbar
figure;
cb = colorbar;
colormap(ap.colormap('WG'));
clim([-clim_val, clim_val]);
cb.Position = [0.4 0.4 0.015 0.2];  % [x y width height] - centered vertically
cb.FontSize = 10;
cb.Label.String = '\DeltaF/F';
cb.Label.Position= [2.5,0.000005,0];
cb.Label.FontSize = 12;


% Plot learners
figure;
imagesc(img_pre_learning_learners);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
% Get current color limits
title(sprintf('Pre-Learning %s Kernels — mPFC+', statistic));
ap.wf_draw('ccf');

figure;
imagesc(img_post_learning_learners);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title(sprintf('Post-Learning %s Kernels — mPFC+', statistic));
ap.wf_draw('ccf');

% Plot non learners
figure;
imagesc(img_pre_learning_non_learners);
axis image off;
colormap(ap.colormap('GWP'));
clim([-clim_val, clim_val]);
title(sprintf('Pre-Learning %s Kernels— mPFC-', statistic));
ap.wf_draw('ccf');

figure;
imagesc(img_post_learning_non_learners);
axis image off;
colormap(ap.colormap('GWP'));
clim([-clim_val, clim_val]);
title(sprintf('Post-Learning %s Kernels — mPFC-', statistic));
ap.wf_draw('ccf');


%% Plot a bar plot of the pre-post activity change seperated by mPFC+ /mPFC-

% ===== PRE-POST LEARNING COMPARISON PER ANIMAL =====

% Define which ROI to plot
ROI_trace = left_mPFC_ROI_trace; % or left_mPFC_ROI_trace, etc.
ROI_name = 'left mPFC';

% Define protocol
protocol_idx = 1;


% Response window for computing activity
response_window = t_for_plot >= 0 & t_for_plot <= 0.35;

% Get unique animals
animals = unique(widefield_animal_idx);

% Storage for pre/post data
learner_pre = [];
learner_post = [];
learner_ids = [];

nonlearner_pre = [];
nonlearner_post = [];
nonlearner_ids = [];

% Extract pre/post data for each animal
for ai = animals(:)'
    % Get days for this animal in the protocol
    animal_mask = (widefield_animal_idx == ai) & (workflow_cat == protocol_idx);
    animal_days = find(animal_mask);
    
    if isempty(animal_days), continue; end
    
    % Determine if learner or non-learner
    is_learner = ~is_group_animal(animal_days(1));
    
    % Get pre-learning days
    pre_mask = animal_mask & (learning_index_animal == 0);
    pre_traces = ROI_trace(pre_mask, :);
    
    % Get post-learning days
    post_mask = animal_mask & (learning_index_animal == 1);
    post_traces = ROI_trace(post_mask, :);
    
    % Skip if missing either pre or post
    if isempty(pre_traces) || isempty(post_traces)
        continue;
    end
    
    % Compute mean activity across days (max in response window)
    pre_activity = mean(max(pre_traces(:, response_window), [], 2));
    post_activity = mean(max(post_traces(:, response_window), [], 2));
    
    % Store based on group
    if is_learner
        learner_pre = [learner_pre; pre_activity];
        learner_post = [learner_post; post_activity];
        learner_ids = [learner_ids; ai];
    else
        nonlearner_pre = [nonlearner_pre; pre_activity];
        nonlearner_post = [nonlearner_post; post_activity];
        nonlearner_ids = [nonlearner_ids; ai];
    end
end

% Create figure
figure('Position', [100, 100, 1000, 600]);

% Determine global y-limits
all_data = [learner_pre; learner_post; nonlearner_pre; nonlearner_post];
y_min = min(all_data) * 0.9;
y_max = max(all_data) * 1.1;

% Plot mPFC+ (Learners)
subplot(1, 2, 1);
hold on;

n_learners = length(learner_pre);

% Plot individual animals
for i = 1:n_learners
    % Plot line connecting pre to post
    plot([1, 2], [learner_pre(i), learner_post(i)], '-', ...
         'Color', [cmPFC_plus 0.4], 'LineWidth', 1.5);
    
    % Plot dots
    scatter(1, learner_pre(i), 80, cmPFC_plus, 'filled', ...
            'MarkerEdgeColor', 'k', 'LineWidth', 1);
    scatter(2, learner_post(i), 80, cmPFC_plus, 'filled', ...
            'MarkerEdgeColor', 'k', 'LineWidth', 1);
end

% Plot group means
mean_pre = mean(learner_pre);
mean_post = mean(learner_post);

plot([0.7, 1.3], [mean_pre, mean_pre], 'k-', 'LineWidth', 3);
plot([1.7, 2.3], [mean_post, mean_post], 'k-', 'LineWidth', 3);

% Formatting
xlim([0.5, 2.5]);
ylim([y_min, y_max]);
xticks([1, 2]);
xticklabels({'Pre-Learning', 'Post-Learning'});
ylabel('Peak Activity', 'FontSize', 12, 'FontWeight', 'bold');
title(sprintf('mPFC+ Animals (n=%d)', n_learners), 'FontSize', 13, 'FontWeight', 'bold');
set(gca, 'FontSize', 11);
grid on;
box on;
hold off;
% 
% % Add significance test
% [~, p_learner] = ttest(learner_pre, learner_post);
% if p_learner < 0.05
%     y_sig = y_max * 0.95;
%     plot([1, 2], [y_sig, y_sig], 'k-', 'LineWidth', 1.5);
%     if p_learner < 0.001
%         text(1.5, y_sig*1.02, '***', 'HorizontalAlignment', 'center', 'FontSize', 14);
%     elseif p_learner < 0.01
%         text(1.5, y_sig*1.02, '**', 'HorizontalAlignment', 'center', 'FontSize', 14);
%     else
%         text(1.5, y_sig*1.02, '*', 'HorizontalAlignment', 'center', 'FontSize', 14);
%     end
% end

% Plot mPFC- (Non-learners)
subplot(1, 2, 2);
hold on;

n_nonlearners = length(nonlearner_pre);

% Plot individual animals
for i = 1:n_nonlearners
    % Plot line connecting pre to post
    plot([1, 2], [nonlearner_pre(i), nonlearner_post(i)], '-', ...
         'Color', [cmPFC_minus, 0.4], 'LineWidth', 1.5);
    
    % Plot dots
    scatter(1, nonlearner_pre(i), 80, cmPFC_minus, 'filled', ...
            'MarkerEdgeColor', 'k', 'LineWidth', 1);
    scatter(2, nonlearner_post(i), 80, cmPFC_minus, 'filled', ...
            'MarkerEdgeColor', 'k', 'LineWidth', 1);
end

% Plot group means
mean_pre = mean(nonlearner_pre);
mean_post = mean(nonlearner_post);

plot([0.7, 1.3], [mean_pre, mean_pre], 'k-', 'LineWidth', 3);
plot([1.7, 2.3], [mean_post, mean_post], 'k-', 'LineWidth', 3);

% Formatting
xlim([0.5, 2.5]);
ylim([y_min, y_max]);
xticks([1, 2]);
xticklabels({'Pre-Learning', 'Post-Learning'});
ylabel('Peak Activity', 'FontSize', 12, 'FontWeight', 'bold');
title(sprintf('mPFC- Animals (n=%d)', n_nonlearners), 'FontSize', 13, 'FontWeight', 'bold');
set(gca, 'FontSize', 11);
grid on;
box on;
hold off;

% Add significance test
[~, p_nonlearner] = ttest(nonlearner_pre, nonlearner_post);
if p_nonlearner < 0.05
    y_sig = y_max * 0.95;
    plot([1, 2], [y_sig, y_sig], 'k-', 'LineWidth', 1.5);
    if p_nonlearner < 0.001
        text(1.5, y_sig*1.02, '***', 'HorizontalAlignment', 'center', 'FontSize', 14);
    elseif p_nonlearner < 0.01
        text(1.5, y_sig*1.02, '**', 'HorizontalAlignment', 'center', 'FontSize', 14);
    else
        text(1.5, y_sig*1.02, '*', 'HorizontalAlignment', 'center', 'FontSize', 14);
    end
end

% Overall title
sgtitle(sprintf('%s Activity: Pre vs Post Learning', ROI_name), ...
        'FontSize', 14, 'FontWeight', 'bold');

% Print statistics
fprintf('\n===== PRE-POST COMPARISON =====\n');
fprintf('mPFC+ (n=%d):\n', n_learners);
fprintf('  Pre:  %.2e ± %.2e\n', mean(learner_pre), std(learner_pre));
fprintf('  Post: %.2e ± %.2e\n', mean(learner_post), std(learner_post));
fprintf('  p = %.4f (paired t-test)\n', p_learner);

fprintf('\nmPFC- (n=%d):\n', n_nonlearners);
fprintf('  Pre:  %.2e ± %.2e\n', mean(nonlearner_pre), std(nonlearner_pre));
fprintf('  Post: %.2e ± %.2e\n', mean(nonlearner_post), std(nonlearner_post));
fprintf('  p = %.4f (paired t-test)\n', p_nonlearner);


%% Plot individual ROI traces for each animal

protocol_idx=1;  % define protocol

% unique animals
animals = unique(widefield_animal_idx);

for ai = animals(:)'
    % ——— 1) pick out this animal & workflow ———
    sel      = (widefield_animal_idx==ai) & (workflow_cat==protocol_idx);
    days_idx = find(sel);
    if isempty(days_idx), continue; end

    % ——— 2) locate the learning day ———
    learn_local = learning_index_animal(days_idx)==1;
    ld = find(learn_local,1,'first');
    if isempty(ld)
        warning('Animal %d has no learning day; setting it as last day +1 (all pre-learning)', ai);
        ld=length(days_idx)+1;
    end

    % ——— 3) pull out the day×time traces ———
    TR = right_mPFC_ROI_trace(days_idx, :);   % n_days × T
    TL = left_mPFC_ROI_trace(days_idx,  :);   % n_days × T

    % ——— 4) average pre‐ vs post‐ learning across days (preserving time) ———
    pre_mask  = (1:size(TR,1)) < ld;
    post_mask = ~pre_mask;

    R_pre  = mean(TR(pre_mask, :), 1);   % 1 × T
    R_post = mean(TR(post_mask,:), 1);   % 1 × T
    L_pre  = mean(TL(pre_mask, :), 1);   % 1 × T
    L_post = mean(TL(post_mask,:), 1);   % 1 × T



    % ——— 5) plot the time‐courses ———
    figure('Name',sprintf('Animal %s pre/post',animal_list{ai}),'Color','w');
    hold on;
    plot(t_for_plot, R_pre,'color',cmPFC_plus,'LineWidth',2,'LineStyle','--');
    plot(t_for_plot, R_post, 'color',cmPFC_plus,'LineWidth',2);
    plot(t_for_plot, L_pre,  'color',cmPFC_minus,'LineWidth',2,'LineStyle','--');
    plot(t_for_plot, L_post, 'color',cmPFC_minus,'LineWidth',2);
    xline(0,'k--','LineWidth',1.5);      % if t=0 is event
    xlabel('Time (s)');
    ylabel('Mean mPFC activity (a.u.)');
    title(sprintf('Animal %s — pre vs post (R solid/L dotted)',animal_list{ai}));
    legend({'Right pre','Right post','Left pre','Left post'},'Location','best');
    grid on;
    hold off;

end


%% Plot pre-post average split between learners and non-learners for both hemispheres

protocol_idx=1;  % define protocol

% ————— Prepare containers —————
Rpre_L = [];  Rpost_L = [];
Lpre_L = [];  Lpost_L = [];
Rpre_N = [];  Rpost_N = [];
Lpre_N = [];  Lpost_N = [];

for ai = animals(:)'
    % ——— pick out this animal & protocol days ———
    sel      = (widefield_animal_idx==ai) & (workflow_cat==protocol_idx);
    days_idx = find(sel);
    if isempty(days_idx), continue; end

    % ——— find the learning day within those ———
    ld = find(learning_index_animal(days_idx)==1 , 1,'first' );
    if isempty(ld), ld=length(days_idx)+1; end

    % ——— grab the day×time ROI traces ———
    TR = right_mPFC_ROI_trace(days_idx, :);  % n_days×T
    TL = left_mPFC_ROI_trace(days_idx,  :);  % n_days×T

    % ——— split into pre vs post days ———
    pre_mask  = (1:size(TR,1)) < ld;
    post_mask = ~pre_mask;

    R_pre  = mean(TR(pre_mask, :), 1);
    R_post = mean(TR(post_mask,:), 1);
    L_pre  = mean(TL(pre_mask, :), 1);
    L_post = mean(TL(post_mask,:), 1);

    % ——— decide which group this animal is in ———
    grp = is_group_animal(days_idx(1));   % 0 = learner, 1 = non-learner

    if grp == 0
        Rpre_L(end+1,:)  = R_pre;
        Rpost_L(end+1,:) = R_post;
        Lpre_L(end+1,:)  = L_pre;
        Lpost_L(end+1,:) = L_post;
    else
        Rpre_N(end+1,:)  = R_pre;
        Rpost_N(end+1,:) = R_post;
        Lpre_N(end+1,:)  = L_pre;
        Lpost_N(end+1,:) = L_post;
    end
end

% ————— compute group means & SEMs —————
% learners
nLeaners = size(Rpre_L,1);
grpR_pre_L  = nanmean(Rpre_L,1);    semR_pre_L  = nanstd(Rpre_L,0,1)/sqrt(nLeaners);
grpR_post_L = nanmean(Rpost_L,1);   semR_post_L = nanstd(Rpost_L,0,1)/sqrt(nLeaners);
grpL_pre_L  = nanmean(Lpre_L,1);    semL_pre_L  = nanstd(Lpre_L,0,1)/sqrt(nLeaners);
grpL_post_L = nanmean(Lpost_L,1);   semL_post_L = nanstd(Lpost_L,0,1)/sqrt(nLeaners);

% non‐learners
nNon_Leaners = size(Rpre_N,1);
grpR_pre_N  = nanmean(Rpre_N,1);    semR_pre_N  = nanstd(Rpre_N,0,1)/sqrt(nNon_Leaners);
grpR_post_N = nanmean(Rpost_N,1);   semR_post_N = nanstd(Rpost_N,0,1)/sqrt(nNon_Leaners);
grpL_pre_N  = nanmean(Lpre_N,1);    semL_pre_N  = nanstd(Lpre_N,0,1)/sqrt(nNon_Leaners);
grpL_post_N = nanmean(Lpost_N,1);   semL_post_N = nanstd(Lpost_N,0,1)/sqrt(nNon_Leaners);

% ————— plot with SEM shading —————
figure('Color','w','Position',[200 200 800 600]);

% Right mPFC
ax1 = subplot(2,1,1); hold(ax1,'on');

% Right mPFC
subplot(2,1,1); hold on;
% learner pre
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpR_pre_L+semR_pre_L, fliplr(grpR_pre_L-semR_pre_L)], ...
    cmPFC_plus,'FaceAlpha',0.2,'EdgeColor','none');
% learner post
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpR_post_L+semR_post_L, fliplr(grpR_post_L-semR_post_L)], ...
    cmPFC_plus,'FaceAlpha',0.1,'EdgeColor','none');
% nonlearner pre
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpR_pre_N+semR_pre_N, fliplr(grpR_pre_N-semR_pre_N)], ...
    cmPFC_minus,'FaceAlpha',0.2,'EdgeColor','none');
% nonlearner post
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpR_post_N+semR_post_N, fliplr(grpR_post_N-semR_post_N)], ...
    cmPFC_minus,'FaceAlpha',0.1,'EdgeColor','none');

% now lines on top
plot(t_for_plot, grpR_pre_L,  'color',cmPFC_plus,'LineWidth',2,LineStyle='--');
plot(t_for_plot, grpR_post_L, 'color',cmPFC_plus,'LineWidth',2,LineStyle='-');
plot(t_for_plot, grpR_pre_N,  'color',cmPFC_minus,'LineWidth',2,LineStyle='--');
plot(t_for_plot, grpR_post_N, 'color',cmPFC_minus,'LineWidth',2,LineStyle='-');

xline(ax1,0,'k--','LineWidth',1.5);
title(ax1,'Right Visual Cortex');
ylabel(ax1,'Mean activity');
legend(ax1,{'','','',''...
    'Learners Pre','Learners Post','Non-Learners Pre','Non-Learners Post'},'Location','best');grid(ax1,'on');

% Left mPFC
ax2 = subplot(2,1,2); hold(ax2,'on');

% Left mPFC
subplot(2,1,2); hold on;
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpL_pre_L+semL_pre_L, fliplr(grpL_pre_L-semL_pre_L)], ...
    cmPFC_plus,'FaceAlpha',0.2,'EdgeColor','none');
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpL_post_L+semL_post_L, fliplr(grpL_post_L-semL_post_L)], ...
    cmPFC_plus,'FaceAlpha',0.1,'EdgeColor','none');
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpL_pre_N+semL_pre_N, fliplr(grpL_pre_N-semL_pre_N)], ...
    cmPFC_minus,'FaceAlpha',0.2,'EdgeColor','none');
fill([t_for_plot, fliplr(t_for_plot)], ...
    [grpL_post_N+semL_post_N, fliplr(grpL_post_N-semL_post_N)], ...
    cmPFC_minus,'FaceAlpha',0.1,'EdgeColor','none');

plot(t_for_plot, grpL_pre_L,  'color',cmPFC_plus,'LineWidth',2, LineStyle='--');
plot(t_for_plot, grpL_post_L, 'color',cmPFC_plus,'LineWidth',2, LineStyle='-');
plot(t_for_plot, grpL_pre_N, 'color',cmPFC_minus,'LineWidth',2, LineStyle='--');
plot(t_for_plot, grpL_post_N, 'color',cmPFC_minus,'LineWidth',2, LineStyle='-');

xline(ax2,0,'k--','LineWidth',1.5);
title(ax2,'Left Visual Cortex');
xlabel(ax2,'Time (s)');
ylabel(ax2,'Mean activity');
legend(ax2,{'','','',''...
    'Learners Pre','Learners Post','Non-Learners Pre','Non-Learners Post'},'Location','best');
grid(ax2,'on');

% ——— Make y-limits identical ———
yl1 = ylim(ax1);
yl2 = ylim(ax2);
ymin = min(yl1(1), yl2(1));
ymax = max(yl1(2), yl2(2));
set([ax1, ax2], 'YLim', [ymin ymax]);

sgtitle('Group‐average pre vs post learning with SEM');

%% Individual plot lines aligned to learning day


protocol_idx=1;  % define protocol

% data to index:  V×T×Ndays_total
aligned_all = right_stim_v_stacked_data;

% Define the time window in seconds (0 to 200ms)
start_time = 0; % 0s (0ms)
end_time = 0.2; % 0.2s (200ms)

% Find the corresponding indices in added_time for the time window
event_time_window_mask = find(added_time >= start_time & added_time <= end_time);

right_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:),[],[], right_mPFC_ROI_mask), ...
    [3,2,1] );   % gives Ndays_total × T
left_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:),[],[], left_mPFC_ROI_mask), ...
    [3,2,1] );   % same dims


for ai = animals(:)'

    % 1) pick out this animal & protocol days
    sel      = (widefield_animal_idx==ai) & (workflow_cat==protocol_idx);
    days_idx = find(sel);
    if isempty(days_idx), continue; end

    % determine if this animal is a learner (0) or non-learner (1)
    grp = is_group_animal(days_idx(1));
    if     grp==0
        ls = '-';  % solid for learners
        ttl = 'Learner';
    else
        ls = '--'; % dashed for non-learners
        ttl = 'Non-learner';
    end

    % 2) find learning–day
    ld = find(learning_index_animal(days_idx)==1,1,'first');
    if isempty(ld)
        warning('Animal %d has no learning day; skipping.', ai);
        continue;
    end

    % 3) build relative‐day axis
    n = numel(days_idx);
    rel_day = (1:n) - ld;        % 0 = day of learning

    % 4) mean ROI per day
    meanR = mean(right_mPFC_ROI_trace(days_idx,:), 2);  % n×1
    meanL = mean(left_mPFC_ROI_trace(days_idx,:),  2);  % n×1

    % 5) plot
    figure('Name',sprintf('Animal %s (%s)',animal_list{ai},ttl),'Color','w');
    plot(rel_day, meanR, ['r' ls], 'LineWidth',2, 'Marker','o','MarkerSize',6); hold on;
    plot(rel_day, meanL, ['b' ls], 'LineWidth',2, 'Marker','s','MarkerSize',6);
    xline(0,'k--','LineWidth',1.5);

    xlabel('Days relative to learning');
    ylabel('Mean mPFC activity (a.u.)');
    title(sprintf('Animal %s — %s (R red / L blue)', animal_list{ai}, ttl));
    legend({'Right','Left','Learning Day'},'Location','best');
    grid on;
end



%% Plot the learning day aligned max/mean mPFC activity - colour coded by learners vs non-learners

protocol_idx = 1; % define protocol

% data to index: V×T×Ndays_total
aligned_all = right_stim_kernel;

% unique animals
animals = unique(widefield_animal_idx);

% Define event and baseline time windows
event_times = [0, 0.3];
baseline_time_windows = [-0.1, 0];

% Create logical masks for both
event_time_window_mask = (added_time_Kernel > event_times(1) & added_time_Kernel < event_times(2));
baseline_mask = (added_time_Kernel >= baseline_time_windows(1) & added_time_Kernel <= baseline_time_windows(2));

% Extract ROI traces
right_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:),[],[], right_mPFC_ROI_mask), ...
    [3,2,1] ); % gives Ndays_total × T

left_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:),[],[], left_mPFC_ROI_mask), ...
    [3,2,1] ); % same dims

% Extract baseline ROI traces
right_mPFC_baseline = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,baseline_mask,:),[],[], right_mPFC_ROI_mask), ...
    [3,2,1] ); % Ndays_total × T_baseline

left_mPFC_baseline = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,baseline_mask,:),[],[], left_mPFC_ROI_mask), ...
    [3,2,1] ); % Ndays_total × T_baseline

% Subtract baseline from signal
right_mPFC_ROI_trace = right_mPFC_ROI_trace - mean(right_mPFC_baseline, 2);
left_mPFC_ROI_trace = left_mPFC_ROI_trace - mean(left_mPFC_baseline, 2);

% Initialize to store all relative days
rel_day_all = nan(size(widefield_animal_idx));

% Find the relative day for each individual animal
for curr_animal = 1:length(animals)
    sel = (widefield_animal_idx==curr_animal) & (workflow_cat==protocol_idx);
    days_idx = find(sel);
    ld = find(learning_index_animal(days_idx)==1, 1, 'first');
    
    if isempty(ld)
        continue
    end
    
    n = numel(days_idx);
    rel_day = (1:n) - ld; % 0 = day of learning
    rel_day_all(sel) = rel_day;
end

% Find max activity for each day
left_mPFC_ROI_trace_max = max(left_mPFC_ROI_trace, [], 2); % n×1
right_mPFC_ROI_trace_max = max(right_mPFC_ROI_trace, [], 2); % n×1

combined_mPFC_ROI_trace_max= (left_mPFC_ROI_trace_max+right_mPFC_ROI_trace_max);

% Calculate group averages
[group_avg, groups] = ap.groupfun(@mean, left_mPFC_ROI_trace_max, [rel_day_all, is_group_animal]);

% Calculate SEM for each group
sem_func = @(x) std(x, 'omitnan') / sqrt(sum(~isnan(x)));
[group_sem, groups_sem] = ap.groupfun(sem_func, left_mPFC_ROI_trace_max, [rel_day_all, is_group_animal]);

% To count animals per relative day per group
[group_counts, groups_count] = ap.groupfun(@length, ones(size(widefield_animal_idx)), [rel_day_all, is_group_animal]);


% Filter to keep only days with >2 animals
min_animals = 3;

% Separate learners and non-learners
learner_mask = groups(:,2) == 0;
non_learner_mask = groups(:,2) == 1;

% Filter learners
learner_valid = group_counts(learner_mask) > min_animals;
learner_groups_filtered = groups(learner_mask, :);
learner_groups_filtered = learner_groups_filtered(learner_valid, :);
learner_avg_filtered = group_avg(learner_mask);
learner_avg_filtered = learner_avg_filtered(learner_valid);
learner_sem_filtered = group_sem(learner_mask);
learner_sem_filtered = learner_sem_filtered(learner_valid);

% Sort learners by relative day
[learner_groups_filtered, learner_sort_idx] = sortrows(learner_groups_filtered, 1);
learner_avg_filtered = learner_avg_filtered(learner_sort_idx);
learner_sem_filtered = learner_sem_filtered(learner_sort_idx);

% Filter non-learners
non_learner_valid = group_counts(non_learner_mask) > min_animals;
non_learner_groups_filtered = groups(non_learner_mask, :);
non_learner_groups_filtered = non_learner_groups_filtered(non_learner_valid, :);
non_learner_avg_filtered = group_avg(non_learner_mask);
non_learner_avg_filtered = non_learner_avg_filtered(non_learner_valid);
non_learner_sem_filtered = group_sem(non_learner_mask);
non_learner_sem_filtered = non_learner_sem_filtered(non_learner_valid);

% Sort non-learners by relative day
[non_learner_groups_filtered, non_learner_sort_idx] = sortrows(non_learner_groups_filtered, 1);
non_learner_avg_filtered = non_learner_avg_filtered(non_learner_sort_idx);
non_learner_sem_filtered = non_learner_sem_filtered(non_learner_sort_idx);

% Plot filtered data with SEM
figure; hold on;

% Plot learner SEM shading
learner_days = learner_groups_filtered(:, 1);
fill([learner_days; flipud(learner_days)], ...
     [learner_avg_filtered + learner_sem_filtered; flipud(learner_avg_filtered - learner_sem_filtered)], ...
     cmPFC_plus, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility', 'off');

% Plot learner mean line
plot(learner_days, learner_avg_filtered, '-o', ...
    'LineWidth', 2, 'DisplayName', 'Learners', 'Color', cmPFC_plus, 'MarkerFaceColor', cmPFC_plus);

% Plot non-learner SEM shading
non_learner_days = non_learner_groups_filtered(:, 1);
fill([non_learner_days; flipud(non_learner_days)], ...
     [non_learner_avg_filtered + non_learner_sem_filtered; flipud(non_learner_avg_filtered - non_learner_sem_filtered)], ...
     cmPFC_minus, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility', 'off');

% Plot non-learner mean line
plot(non_learner_days, non_learner_avg_filtered, '-o', ...
    'LineWidth', 2, 'DisplayName', 'Non-Learners', 'Color', cmPFC_minus, 'MarkerFaceColor', cmPFC_minus);

xline(0, 'k--', 'LineWidth', 1.5, 'DisplayName', 'Learning Day');
xlabel('Days Relative to Learning');
ylabel('Max mPFC Activity (Baseline-subtracted)');
title(sprintf('Right Stimulus Left mPFC Activity (Kernels) (days with >%d animals per group)', min_animals));
legend('Location', 'best');
grid on;
hold off;


%%

protocol_idx = 1; % define protocol

% data to index: V×T×Ndays_total
aligned_all = center_stim_v_stacked_data;

% Define the time window in seconds (0 to 200ms)
start_time = 0; 
end_time = 0.35; 

% Define baseline window (-200ms to 0ms)
baseline_start = -0.1; % -200ms
baseline_end = 0; % 0ms

% Find the corresponding indices in added_time for the time window
event_time_window_mask = find(added_time >= start_time & added_time <= end_time);

% Find the corresponding indices for baseline window
baseline_mask = find(added_time >= baseline_start & added_time <= baseline_end);

% Extract ROI traces
right_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:),[],[], right_mPFC_ROI_mask), ...
    [3,2,1] ); % gives Ndays_total × T

left_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:),[],[], left_mPFC_ROI_mask), ...
    [3,2,1] ); % same dims

% Extract baseline ROI traces
right_mPFC_baseline = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,baseline_mask,:),[],[], right_mPFC_ROI_mask), ...
    [3,2,1] ); % Ndays_total × T_baseline

left_mPFC_baseline = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,baseline_mask,:),[],[], left_mPFC_ROI_mask), ...
    [3,2,1] ); % Ndays_total × T_baseline

% Compute baseline mean for each day (average across time)
right_baseline_mean = mean(right_mPFC_baseline, 2); % Ndays_total × 1
left_baseline_mean = mean(left_mPFC_baseline, 2); % Ndays_total × 1

% Subtract baseline from signal
right_mPFC_ROI_trace = right_mPFC_ROI_trace - right_baseline_mean;
left_mPFC_ROI_trace = left_mPFC_ROI_trace - left_baseline_mean;

% Storage for aligned data (separated by group)
learner_data = {};
non_learner_data = {};

%%% Alt way to do grouping with ap.groupfun

rel_day_all = nan(size(widefield_animal_idx));
for curr_animal = 1:length(animals)
    sel = (widefield_animal_idx==curr_animal) & (workflow_cat==protocol_idx);
    days_idx = find(sel);
    ld = find(learning_index_animal(days_idx)==1, 1, 'first');
    if isempty(ld)
        continue
    end
    n = numel(days_idx);
    rel_day = (1:n) - ld; % 0 = day of learning
    rel_day_all(sel) = rel_day;
end

left_mPFC_ROI_trace_max = max(left_mPFC_ROI_trace,[], 2); % n×1

[group_avg,groups] = ap.groupfun(@mean,left_mPFC_ROI_trace_max,[rel_day_all,is_group_animal]);

figure; hold on
plot(groups(groups(:,2)==0,1),group_avg(groups(:,2)==0));
plot(groups(groups(:,2)==1,1),group_avg(groups(:,2)==1));

%%%

% Loop through animals to collect aligned data
for ai = animals(:)'
    % 1) pick out this animal & protocol days
    sel = (widefield_animal_idx==ai) & (workflow_cat==protocol_idx);
    days_idx = find(sel);
    
    if isempty(days_idx), continue; end
    
    % determine if this animal is a learner (0) or non-learner (1)
    grp = is_group_animal(days_idx(1));
    
    % 2) find learning day
    ld = find(learning_index_animal(days_idx)==1, 1, 'first');
    if isempty(ld)
        warning('Animal %d has no learning day; skipping.', ai);
        continue;
    end
    
    % 3) build relative-day axis
    n = numel(days_idx);
    rel_day = (1:n) - ld; % 0 = day of learning
    
    % 4) mean ROI per day (focus on left hemisphere only)
    meanL = max(left_mPFC_ROI_trace(days_idx,:),[], 2); % n×1
    
    % 5) Store data with relative days
    animal_data = struct('rel_day', rel_day, 'activity', meanL, 'animal_id', ai);
    
    if grp == 0 % learner
        learner_data{end+1} = animal_data;
    else % non-learner
        non_learner_data{end+1} = animal_data;
    end
end

% Find the range of relative days across all animals
all_rel_days = [];
for i = 1:length(learner_data)
    all_rel_days = [all_rel_days, learner_data{i}.rel_day];
end
for i = 1:length(non_learner_data)
    all_rel_days = [all_rel_days, non_learner_data{i}.rel_day];
end

min_day = min(all_rel_days);
max_day = max(all_rel_days);
day_range = min_day:max_day;

% Compute group averages and count animals per day (for each group separately)
learner_avg = nan(size(day_range));
learner_sem = nan(size(day_range));
learner_n_per_day = zeros(size(day_range));

non_learner_avg = nan(size(day_range));
non_learner_sem = nan(size(day_range));
non_learner_n_per_day = zeros(size(day_range));

for d_idx = 1:length(day_range)
    curr_day = day_range(d_idx);
    
    % Collect learner values for this day
    learner_vals = [];
    for i = 1:length(learner_data)
        day_match = find(learner_data{i}.rel_day == curr_day);
        if ~isempty(day_match)
            learner_vals = [learner_vals; learner_data{i}.activity(day_match)];
        end
    end
    
    learner_n_per_day(d_idx) = length(learner_vals);
    
    if ~isempty(learner_vals)
        learner_avg(d_idx) = mean(learner_vals, 'omitnan');
        learner_sem(d_idx) = std(learner_vals, 'omitnan') / sqrt(length(learner_vals));
    end
    
    % Collect non-learner values for this day
    non_learner_vals = [];
    for i = 1:length(non_learner_data)
        day_match = find(non_learner_data{i}.rel_day == curr_day);
        if ~isempty(day_match)
            non_learner_vals = [non_learner_vals; non_learner_data{i}.activity(day_match)];
        end
    end
    
    non_learner_n_per_day(d_idx) = length(non_learner_vals);
    
    if ~isempty(non_learner_vals)
        non_learner_avg(d_idx) = mean(non_learner_vals, 'omitnan');
        non_learner_sem(d_idx) = std(non_learner_vals, 'omitnan') / sqrt(length(non_learner_vals));
    end
end

% Filter to only include days with >3 animals for each group
learner_valid_mask = learner_n_per_day > 2;
learner_valid_days = day_range(learner_valid_mask);
learner_valid_avg = learner_avg(learner_valid_mask);
learner_valid_sem = learner_sem(learner_valid_mask);

non_learner_valid_mask = non_learner_n_per_day > 3;
non_learner_valid_days = day_range(non_learner_valid_mask);
non_learner_valid_avg = non_learner_avg(non_learner_valid_mask);
non_learner_valid_sem = non_learner_sem(non_learner_valid_mask);



% Create figure
figure('Color','w','Position',[100 100 800 600]);
hold on;

% Plot individual learner trajectories (thin blue lines)
for i = 1:length(learner_data)
    animal_rel_days = learner_data{i}.rel_day;
    animal_activity = learner_data{i}.activity;
    
    % Filter to only valid days
    valid_idx = ismember(animal_rel_days, learner_valid_days);
    
    if any(valid_idx)
        plot(animal_rel_days(valid_idx), animal_activity(valid_idx), '-', ...
            'Color', [cmPFC_plus 0.3], 'LineWidth', 0.5, 'HandleVisibility', 'off');
    end
end

% Plot individual non-learner trajectories (thin orange lines)
for i = 1:length(non_learner_data)
    animal_rel_days = non_learner_data{i}.rel_day;
    animal_activity = non_learner_data{i}.activity;
    
    % Filter to only valid days
    valid_idx = ismember(animal_rel_days, non_learner_valid_days);
    
    if any(valid_idx)
        plot(animal_rel_days(valid_idx), animal_activity(valid_idx), '-', ...
            'Color', [cmPFC_minus 0.3], 'LineWidth', 0.5, 'HandleVisibility', 'off');
    end
end

% Plot learner group average (thick blue line)
if ~isempty(learner_valid_days)
    plot(learner_valid_days, learner_valid_avg, '-', ...
        'Color', cmPFC_plus, 'LineWidth', 3, 'DisplayName', 'Learner Average');
    
    % Add SEM shading
    fill([learner_valid_days fliplr(learner_valid_days)], ...
        [learner_valid_avg+learner_valid_sem, fliplr(learner_valid_avg-learner_valid_sem)], ...
        cmPFC_plus, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility','off');
end

% Plot non-learner group average (thick orange line)
if ~isempty(non_learner_valid_days)
    plot(non_learner_valid_days, non_learner_valid_avg, '-', ...
        'Color', cmPFC_minus, 'LineWidth', 3, 'DisplayName', 'Non-Learner Average');
    
    % Add SEM shading
    fill([non_learner_valid_days fliplr(non_learner_valid_days)], ...
        [non_learner_valid_avg+non_learner_valid_sem, fliplr(non_learner_valid_avg-non_learner_valid_sem)], ...
        cmPFC_minus, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility','off');
end

xline(0, 'k--', 'LineWidth', 2, 'DisplayName', 'Learning Day');
xlabel('Days Relative to Learning');
ylabel('Mean Left mPFC Activity (Baseline-subtracted, a.u.)');
title(sprintf('Left mPFC Activity - Learners (n=%d) vs Non-Learners (n=%d)', ...
    length(learner_data), length(non_learner_data)));
legend('Location', 'best');
grid on;
hold off;

%% Draw an average plot line of all protocols together seperated learners vs non-learners


% data to index:  V×T×Ndays_total
aligned_all = rewarded_stim_v_stacked_data;

% --- 1) Choose time window and extract ROI traces (Ndays × Twin) ---
start_time = 0;  end_time = 0.3;

% added_time_Kernel;
added_time;

event_time_window_mask = find(added_time >= start_time & added_time <= end_time);

right_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:), [], [], right_mPFC_ROI_mask), ...
    [3,2,1]);  % Ndays × Twin
left_mPFC_ROI_trace  = permute( ...
    ap.wf_roi(wf_U(:,:,1:n_components), aligned_all(:,event_time_window_mask,:), [], [], left_mPFC_ROI_mask), ...
    [3,2,1]);  % Ndays × Twin


protocols = unique(workflow_cat(:))';          % plot segments in this order
groupColor = {cmPFC_plus, cmPFC_minus};          % 0->Learners, 1->Non-learners
labels     = {'Learners','Non-learners'};

% ---------- per-PROTOCOL stats (mean ± SEM vs relative day for each group) ----------
statsP = cell(numel(protocols),1);   % statsP{p}.G(g+1).rel/mR/sR/mL/sL

for ip = 1:numel(protocols)
    p = protocols(ip);

    rel_all = []; grp_all = []; R_all = []; L_all = [];
    for ai = unique(widefield_animal_idx(:))'
        sel = (widefield_animal_idx==ai) & (workflow_cat==p);
        days_idx = find(sel);
        if isempty(days_idx), continue; end

        grp = is_group_animal(days_idx(1));                  % 0/1 per animal
        ld  = find(learning_index_animal(days_idx)==1, 1);   % learning day within this protocol
        if isempty(ld), continue; end

        n = numel(days_idx);
        rel_day = (1:n) - ld;

        meanR = mean(right_mPFC_ROI_trace(days_idx,:), 2, 'omitnan');
        meanL = mean(left_mPFC_ROI_trace (days_idx,:), 2, 'omitnan');

        rel_all = [rel_all; rel_day(:)];
        grp_all = [grp_all; repmat(grp,n,1)];
        R_all   = [R_all;   meanR(:)];
        L_all   = [L_all;   meanL(:)];
    end

    Gpresent = unique(grp_all(:))';
    stats = struct([]);
    for g = Gpresent
        mask = (grp_all==g);
        r    = rel_all(mask);
        Rg   = R_all(mask);
        Lg   = L_all(mask);

        uRel = unique(r,'sorted');
        mR = nan(size(uRel)); sR = nan(size(uRel));
        mL = nan(size(uRel)); sL = nan(size(uRel));
        for k = 1:numel(uRel)
            idx = (r==uRel(k));
            Rk = Rg(idx); Rk = Rk(~isnan(Rk));
            Lk = Lg(idx); Lk = Lk(~isnan(Lk));
            mR(k) = mean(Rk); sR(k) = std(Rk)/max(1,sqrt(numel(Rk)));
            mL(k) = mean(Lk); sL(k) = std(Lk)/max(1,sqrt(numel(Lk)));
        end
        stats(g+1).rel = uRel(:);
        stats(g+1).mR  = mR(:); stats(g+1).sR = sR(:);
        stats(g+1).mL  = mL(:); stats(g+1).sL = sL(:);
    end
    statsP{ip} = stats;
end

% ---------- global y-limits across all protocols & groups ----------
yvals = [];
for ip = 1:numel(protocols)
    st = statsP{ip}; if isempty(st), continue; end
    for gi = 1:numel(st)
        if isempty(st(gi)), continue; end
        yvals = [yvals; st(gi).mR+st(gi).sR; st(gi).mR-st(gi).sR; ...
                        st(gi).mL+st(gi).sL; st(gi).mL-st(gi).sL];
    end
end
yvals = yvals(~isnan(yvals));
ymin = max(-3, min(yvals));  ymax = max(yvals);

% ---------- PLOT: concatenate protocol segments, each aligned internally to its learning day ----------
figure('Color','w','Name','Summary by protocol (aligned inside each segment)');
tiledlayout(2,1,'TileSpacing','compact');   % Row1=Right, Row2=Left

spacer = 1;   % gap (days) between protocol segments

for hemi = 1:2
    nexttile; hold on;
    offset = 0;    % cumulative x-offset (in "days")

    for ip = 1:numel(protocols)
        st = statsP{ip};
        if isempty(st), offset = offset + spacer; continue; end

        % Span within this protocol (relative day range across groups)
        minRel = inf; maxRel = -inf;
        for gi = 1:numel(st)
            if isempty(st(gi)), continue; end
            minRel = min(minRel, min(st(gi).rel));
            maxRel = max(maxRel, max(st(gi).rel));
        end
        if ~isfinite(minRel) || ~isfinite(maxRel)
            offset = offset + spacer; continue;
        end
        span = maxRel - minRel;

        % Draw each group in its color
        for g = [0 1]   % force order: learners then non-learners
            gi = g+1;
            if gi>numel(st) || isempty(st(gi)), continue; end
            s = st(gi);
            col = groupColor{gi};

            % choose hemisphere series
            if hemi==1, m = s.mR; 
                se = s.sR; ylab = 'Right mPFC (a.u.)';
                
            else       
                m = s.mL; se = s.sL; ylab = 'Left mPFC (a.u.)';
            end

            % x for this segment: shift so the segment starts at 'offset'
            % (i.e., map minRel -> offset; learning day 0 sits at offset + (0 - minRel))
            [rel_sorted, ord] = sort(s.rel);
            m  = m(ord);  se = se(ord);
            x  = offset + (rel_sorted - minRel);

            % SEM ribbon
            xf = [x; flipud(x)];
            yf = [m+se; flipud(m-se)];
            fill(xf, yf, col, 'FaceAlpha', 0.18, 'EdgeColor','none', 'HandleVisibility','off');

            % mean line
            plot(x, m, '-', 'Color', col, 'LineWidth', 2, 'DisplayName', labels{gi});
        end

        % learning-day marker within this segment (relative day == 0)
        x0 = offset + (0 - minRel);
        xline(x0,'k--','HandleVisibility','off');

        % protocol label centered over the segment
        xc = offset + span/2;
        yl = ylim; text(xc, yl(2), sprintf('Protocol %d', protocols(ip)), ...
                        'HorizontalAlignment','center','VerticalAlignment','top', ...
                        'FontSize',9,'Interpreter','none','Color',[0 0 0 0.6]);

        % advance offset for next segment
        offset = offset + span + spacer;
    end

    grid on; box off; ylim([ymin ymax]);
    xlabel('Concatenated relative day (segments separated by learning-day-aligned spans)');
    ylabel(ylab);
    legend('Location','best'); % Learners vs Non-learners
end



%% Plots a scatter plot of left vs right mPFC to show the seperation of mPFC+ and mPFC- groups

% Parameters
left_mPFC_ROI = left_mPFC_ROI_mask;   % Left mPFC ROI index
right_mPFC_ROI = right_mPFC_ROI_mask; % Right mPFC ROI index
n_components; % Number of SVD components

% Time window for CS+ response
time_window_start = 0;    % Start of response window (s)
time_window_end = 0.35;   % End of response window (s)

% Initialize storage
left_mPFC_magnitude = nan(numel(behaviour_data), 1);
right_mPFC_magnitude = nan(numel(behaviour_data), 1);
mPFC_metadata_two_days = struct();

for a = 1:numel(behaviour_data)
    aid = string(behaviour_data(a).animal_id);
    rd = behaviour_data(a).recording_day;
    
    if isempty(rd)
        fprintf('Animal %s: No recording days, skipping\n', aid);
        continue;
    end
    
    % Find classical conditioning days (Stage 1)
    isClassical = arrayfun(@(d) isfield(d,'workflow') && contains(d.workflow,'right_move'), rd);
    
    if ~any(isClassical)
        fprintf('Animal %s: No classical days, skipping\n', aid);
        continue;
    end
    
    % Check if learned Stage 1
    classical_days = find(isClassical);
    sigDays = combined_sig_day_all_protocols{a}(classical_days);
    learned_day = find(sigDays, 1, 'first');
    
    if isempty(learned_day)
        fprintf('Animal %s: Never learned Stage 1, skipping\n', aid);
        continue;
    end
    
    % Get last TWO classical days
    if length(classical_days) < 3
        fprintf('Animal %s: Only 1 classical day, using just that day\n', aid);
        days_to_use = classical_days(end);
    else
        days_to_use = classical_days(end-2:end); % Last two days
    end

    % Extract mPFC for each of the last two days
    left_mPFC_responses = nan(1, length(days_to_use));
    right_mPFC_responses = nan(1, length(days_to_use));
    
    day_counter = 0;

    for day_idx = days_to_use
        day_counter = day_counter + 1;
        
        % Find matching widefield index
        matching_idx = find(widefield_animal_idx == a); % get all days indices
        matching_idx = matching_idx(day_idx); % get the specific day

        if isempty(matching_idx)
            fprintf('  Day %d: No widefield data\n', day_idx);
            continue;
        end
        
        % Extract LEFT mPFC ROI activity
        left_mPFC_trace_avg = ap.wf_roi(wf_U(:,:,1:n_components), ...
            right_stim_kernel(:,:,matching_idx(1)), [], [], left_mPFC_ROI);
        
        % Extract RIGHT mPFC ROI activity
        right_mPFC_trace_avg = ap.wf_roi(wf_U(:,:,1:n_components), ...
            right_stim_kernel(:,:,matching_idx(1)), [], [], right_mPFC_ROI);

        % Find response window indices
        response_window_idx = added_time_Kernel > time_window_start & added_time_Kernel <= time_window_end;
        baseline_window_idx = added_time_Kernel >= -0.1 & added_time_Kernel < 0;

        % Calculate baseline-corrected response for LEFT mPFC
        baseline_left = mean(left_mPFC_trace_avg(baseline_window_idx), 'omitnan');
        response_left = max(left_mPFC_trace_avg(response_window_idx));
        left_mPFC_response_corrected = response_left - baseline_left;
        
        % Calculate baseline-corrected response for RIGHT mPFC
        baseline_right = mean(right_mPFC_trace_avg(baseline_window_idx), 'omitnan');
        response_right = max(right_mPFC_trace_avg(response_window_idx));
        right_mPFC_response_corrected = response_right - baseline_right;
        
        % Store this day's responses
        left_mPFC_responses(day_counter) = left_mPFC_response_corrected;
        right_mPFC_responses(day_counter) = right_mPFC_response_corrected;
    end
    
    % Average across the last two days
    if ~isempty(left_mPFC_responses) && any(~isnan(left_mPFC_responses))
        left_mPFC_magnitude(a) = mean(left_mPFC_responses, 'omitnan');
        right_mPFC_magnitude(a) = mean(right_mPFC_responses, 'omitnan');
        
        % Store metadata
        mPFC_metadata_two_days(a).animal_id = aid;
        mPFC_metadata_two_days(a).days_used = days_to_use;
        mPFC_metadata_two_days(a).left_responses_per_day = left_mPFC_responses;
        mPFC_metadata_two_days(a).right_responses_per_day = right_mPFC_responses;
        mPFC_metadata_two_days(a).mean_left = mean(left_mPFC_responses, 'omitnan');
        mPFC_metadata_two_days(a).mean_right = mean(right_mPFC_responses, 'omitnan');
        
        fprintf('Animal %s: Left mPFC = %.4f, Right mPFC = %.4f\n', ...
            aid, left_mPFC_magnitude(a), right_mPFC_magnitude(a));
    else
        fprintf('Animal %s: No valid mPFC data extracted\n', aid);
    end
end

% ===== Prepare Data for Plotting =====

valid_animals = ~isnan(left_mPFC_magnitude) & ~isnan(right_mPFC_magnitude);
n_valid = sum(valid_animals);

learners_group_ID= ['HA005';'HA008';'HA010';'HA011';'HA012'];
% Create a mask for learners
is_learner = ismember(animal_list, learners_group_ID);

% Get valid data
left_mPFC_data = left_mPFC_magnitude(valid_animals);
right_mPFC_data = right_mPFC_magnitude(valid_animals);
is_learner_valid = is_learner(valid_animals);

% Separate by group
learner_left = left_mPFC_data(is_learner_valid);
learner_right = right_mPFC_data(is_learner_valid);
nonlearner_left = left_mPFC_data(~is_learner_valid);
nonlearner_right = right_mPFC_data(~is_learner_valid);

% Plot scatter

figure('Color', 'w', 'Position', [100 100 1400 600]);
% Find axis limits (same for both panels)
all_data = [left_mPFC_data; right_mPFC_data];
axis_min = min(all_data) * 1.1;
axis_max = max(all_data) * 1.1;

% Panel 1: All gray (no color coding)
subplot(1, 2, 1);
hold on;
% Plot all animals in gray
scatter(left_mPFC_data, right_mPFC_data, 150, [0.5 0.5 0.5], 'filled', ...
    'MarkerEdgeColor', 'k', 'LineWidth', 1.5, 'MarkerFaceAlpha', 0.7);
% Add unity line
plot([axis_min axis_max], [axis_min axis_max], 'k--', 'LineWidth', 2, ...
    'HandleVisibility', 'off');
xlabel('Left mPFC Activity (ΔF/F)', 'FontSize', 14, 'FontWeight', 'bold');
ylabel('Right mPFC Activity (ΔF/F)', 'FontSize', 14, 'FontWeight', 'bold');
title('Left vs Right mPFC 2 Last Days Stage 1', 'FontSize', 16, 'FontWeight', 'bold');
% Add diagonal reference lines
xline(0, 'k:', 'LineWidth', 1.5, 'HandleVisibility', 'off');
yline(0, 'k:', 'LineWidth', 1.5, 'HandleVisibility', 'off');
axis equal;
xlim([0 axis_max]);
ylim([0 axis_max]);
set(gca, 'FontSize', 12, 'LineWidth', 1.5, 'Box', 'on');

% Panel 2: Color coded by learner/non-learner
subplot(1, 2, 2);
hold on;
% Plot non-learners
scatter(nonlearner_left, nonlearner_right, 150, cmPFC_minus, 'filled', ...
    'MarkerEdgeColor', 'k', 'LineWidth', 1.5, 'MarkerFaceAlpha', 0.7, ...
    'DisplayName', sprintf('Non-learners (n=%d)', length(nonlearner_left)));
% Plot learners
scatter(learner_left, learner_right, 150, cmPFC_plus, 'filled', ...
    'MarkerEdgeColor', 'k', 'LineWidth', 1.5, 'MarkerFaceAlpha', 0.7, ...
    'DisplayName', sprintf('Learners (n=%d)', length(learner_left)));
% Add unity line
plot([axis_min axis_max], [axis_min axis_max], 'k--', 'LineWidth', 2, ...
    'HandleVisibility', 'off');
xlabel('Left mPFC Activity (ΔF/F)', 'FontSize', 14, 'FontWeight', 'bold');
ylabel('Right mPFC Activity (ΔF/F)', 'FontSize', 14, 'FontWeight', 'bold');
title('Stage 2 Transfer Groups', 'FontSize', 16, 'FontWeight', 'bold');
% Add diagonal reference lines
xline(0, 'k:', 'LineWidth', 1.5, 'HandleVisibility', 'off');
yline(0, 'k:', 'LineWidth', 1.5, 'HandleVisibility', 'off');
legend('Location', 'northwest', 'FontSize', 11);
axis equal;
xlim([0 axis_max]);
ylim([0 axis_max]);
set(gca, 'FontSize', 12, 'LineWidth', 1.5, 'Box', 'on');



%% A summary plot mPFC activity across differnet stages split by mPFC+ and mPFC-

% data to index:  V×T×Ndays_total
aligned_all = rewarded_stim_kernel;

% --- 1) Choose time window and extract ROI traces (Ndays × Twin) ---
start_time = 0;  
end_time = 0.35;

% Baseline window for subtraction
baseline_start = -0.1;
baseline_end = 0;

% added_time;
event_time_window_mask = find(added_time_Kernel >= start_time & added_time_Kernel <= end_time);
baseline_window_mask = find(added_time_Kernel >= baseline_start & added_time_Kernel <= baseline_end);

% Define ROIs
ROI_to_plot_1=right_mPFC_ROI_mask;
ROI_to_plot_2=left_mPFC_ROI_mask;

% Extract ROI traces for event window
right_mPFC_ROI_trace = permute( ...
    ap.wf_roi(wf_U(:,:,1:kernel_n_components), aligned_all(:,event_time_window_mask,:), [], [], ROI_to_plot_1), ...
    [3,2,1]);  % Ndays × Twin

left_mPFC_ROI_trace  = permute( ...
    ap.wf_roi(wf_U(:,:,1:kernel_n_components), aligned_all(:,event_time_window_mask,:), [], [], ROI_to_plot_2), ...
    [3,2,1]);  % Ndays × Twin

% Extract ROI traces for baseline window
right_mPFC_baseline = permute( ...
    ap.wf_roi(wf_U(:,:,1:kernel_n_components), aligned_all(:,baseline_window_mask,:), [], [], ROI_to_plot_1), ...
    [3,2,1]);  % Ndays × Tbaseline

left_mPFC_baseline  = permute( ...
    ap.wf_roi(wf_U(:,:,1:kernel_n_components), aligned_all(:,baseline_window_mask,:), [], [], ROI_to_plot_2), ...
    [3,2,1]);  % Ndays × Tbaseline

% Compute baseline mean for each day
right_baseline_mean = mean(right_mPFC_baseline, 2, 'omitnan');  % Ndays × 1
left_baseline_mean = mean(left_mPFC_baseline, 2, 'omitnan');    % Ndays × 1

% Subtract baseline from event window
right_mPFC_ROI_trace = right_mPFC_ROI_trace - right_baseline_mean;
left_mPFC_ROI_trace = left_mPFC_ROI_trace - left_baseline_mean;

protocols = unique(workflow_cat(:))';          % plot segments in this order
groupColor = {cmPFC_plus, cmPFC_minus};          % 0->Learners, 1->Non-learners
labels     = {'Learners','Non-learners'};

% Minimum number of animals required per day
min_animals_per_day = 3;

% ---------- per-PROTOCOL stats (mean ± SEM vs relative day for each group) ----------
statsP = cell(numel(protocols),1);   % statsP{p}.G(g+1).rel/mR/sR/mL/sL

for ip = 1:numel(protocols)
    p = protocols(ip);

    % Store per-animal data with animal IDs for counting
    rel_all = []; 
    grp_all = []; 
    R_all = []; 
    L_all = [];
    animal_id_all = [];  % NEW: track which animal each data point comes from
    
    for ai = unique(widefield_animal_idx(:))'
        sel = (widefield_animal_idx==ai) & (workflow_cat==p);
        days_idx = find(sel);
        if isempty(days_idx), continue; end

        grp = is_group_animal(days_idx(1)); % skip non-learners for now
        if grp==1
            continue
        end

        ld  = find(learning_index_animal(days_idx)==1, 1);   % learning day within this protocol
        if isempty(ld), continue; end 

        n = numel(days_idx);
        rel_day = (1:n) - ld;

        meanR = max(right_mPFC_ROI_trace(days_idx,:),[], 2, 'omitnan');
        meanL = max(left_mPFC_ROI_trace (days_idx,:), [],2, 'omitnan');

        rel_all = [rel_all; rel_day(:)];
        grp_all = [grp_all; repmat(grp,n,1)];
        R_all   = [R_all;   meanR(:)];
        L_all   = [L_all;   meanL(:)];
        animal_id_all = [animal_id_all; repmat(ai, n, 1)];  % NEW: store animal ID
    end

    Gpresent = unique(grp_all(:))';
    stats = struct([]);
    
    for g = Gpresent
        mask = (grp_all==g);
        r    = rel_all(mask);
        Rg   = R_all(mask);
        Lg   = L_all(mask);
        animal_ids = animal_id_all(mask);  % NEW: get animal IDs for this group

        uRel = unique(r,'sorted');
        mR = nan(size(uRel)); 
        sR = nan(size(uRel));
        mL = nan(size(uRel)); 
        sL = nan(size(uRel));
        n_animals = nan(size(uRel));  % NEW: track number of animals per day
        
        for k = 1:numel(uRel)
            idx = (r==uRel(k));
            Rk = Rg(idx); 
            Lk = Lg(idx); 
            animals_this_day = animal_ids(idx);  % NEW: get animals for this day
            
            % Remove NaN values
            valid_R = ~isnan(Rk);
            valid_L = ~isnan(Lk);
            Rk = Rk(valid_R);
            Lk = Lk(valid_L);
            
            % Count unique animals for this day
            n_animals(k) = numel(unique(animals_this_day));  % NEW
            
            % Only compute statistics if we have minimum number of animals
            if n_animals(k) >= min_animals_per_day  % NEW: filter by animal count
                mR(k) = mean(Rk); 
                sR(k) = std(Rk)/max(1,sqrt(numel(Rk)));
                mL(k) = mean(Lk); 
                sL(k) = std(Lk)/max(1,sqrt(numel(Lk)));
            else
                % Set to NaN if insufficient animals
                mR(k) = NaN;
                sR(k) = NaN;
                mL(k) = NaN;
                sL(k) = NaN;
            end
        end
        
        % NEW: Filter out days with insufficient animals
        valid_days = n_animals >= min_animals_per_day;
        
        stats(g+1).rel = uRel(valid_days);
        stats(g+1).mR  = mR(valid_days); 
        stats(g+1).sR  = sR(valid_days);
        stats(g+1).mL  = mL(valid_days); 
        stats(g+1).sL  = sL(valid_days);
        stats(g+1).n_animals = n_animals(valid_days);  % NEW: store animal counts
    end
    statsP{ip} = stats;
end

% ---------- global y-limits across all protocols & groups ----------
yvals = [];
for ip = 1:numel(protocols)
    st = statsP{ip}; if isempty(st), continue; end
    for gi = 1:numel(st)
        if isempty(st(gi)), continue; end
        yvals = [yvals; st(gi).mR+st(gi).sR; st(gi).mR-st(gi).sR; ...
                        st(gi).mL+st(gi).sL; st(gi).mL-st(gi).sL];
    end
end
yvals = yvals(~isnan(yvals));
ymin = max(-3, min(yvals));  
ymax = max(yvals);

% ---------- PLOT: concatenate protocol segments, each aligned internally to its learning day ----------
figure('Color','w','Position', [100, 100, 1400, 800], ...
       'Name', sprintf('Summary by protocol (aligned, baseline-subtracted, min %d animals)', min_animals_per_day));
tiledlayout(2,1,'TileSpacing','compact');   % Row1=Right, Row2=Left

spacer = 1;   % gap (days) between protocol segments

for hemi = 1:2
    nexttile; hold on;
    offset = 0;    % cumulative x-offset (in "days")

    for ip = 1:numel(protocols)-1 % if you want to skip 3rd protocol
        st = statsP{ip};
        if isempty(st), offset = offset + spacer; continue; end

        % Span within this protocol (relative day range across groups)
        minRel = inf; maxRel = -inf;
        for gi = 1:numel(st)
            if isempty(st(gi)) || isempty(st(gi).rel), continue; end
            minRel = min(minRel, min(st(gi).rel));
            maxRel = max(maxRel, max(st(gi).rel));
        end
        if ~isfinite(minRel) || ~isfinite(maxRel)
            offset = offset + spacer; continue;
        end
        span = maxRel - minRel;

        % Draw each group in its color
        for g = [0 1]   % force order: learners then non-learners
            gi = g+1;
            if gi>numel(st) || isempty(st(gi)) || isempty(st(gi).rel), continue; end
            s = st(gi);
            col = groupColor{gi};

            % choose hemisphere series
            if hemi==1
                m = s.mR; 
                se = s.sR; 
                ylab = 'Max Right mPFC (ΔF/F)';
            else       
                m = s.mL; 
                se = s.sL; 
                ylab = 'Max Left mPFC (ΔF/F)';
            end

            % x for this segment: shift so the segment starts at 'offset'
            [rel_sorted, ord] = sort(s.rel);
            m  = m(ord);  
            se = se(ord);
            x  = offset + (rel_sorted - minRel);

            % SEM ribbon
            xf = [x; flipud(x)];
            yf = [m+se; flipud(m-se)];
            fill(xf, yf, col, 'FaceAlpha', 0.2, 'EdgeColor','none', 'HandleVisibility','off');

            % mean line
            plot(x, m, '-o', 'Color', col, 'LineWidth', 2.5, 'MarkerSize', 6, ...
                 'MarkerFaceColor', col, 'DisplayName', labels{gi});
        end

        % learning-day marker within this segment (relative day == 0)
        % Only draw if day 0 has sufficient animals in at least one group
        day_zero_exists = false;
        for gi = 1:numel(st)
            if ~isempty(st(gi)) && any(st(gi).rel == 0)
                day_zero_exists = true;
                break;
            end
        end
        
        if day_zero_exists
            x0 = offset + (0 - minRel);
            xline(x0,'k--','LineWidth', 1.5, 'HandleVisibility','off');
            text(x0, ymin + (ymax), 'Learning Day', ...
                 'HorizontalAlignment','center', 'VerticalAlignment','bottom', ...
                 'FontSize', 9, 'FontWeight', 'bold');
        end

        % protocol label centered over the segment
        xc = offset + span/2;
        yl = ylim; 
        text(xc-1, ymax, sprintf('Stage %d', protocols(ip)), ...
             'HorizontalAlignment','center','VerticalAlignment','top', ...
             'FontSize', 11, 'FontWeight', 'bold', 'Interpreter','none', 'Color',[0 0 0 0.7]);

        % advance offset for next segment
        offset = offset + span + spacer;
    end

    ylim([ymin ymax]);
    xlabel('Concatenated Days Aligned Relative to Learning Day', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel(ylab, 'FontSize', 12, 'FontWeight', 'bold');
    % legend('Location','best', 'FontSize', 11);
    set(gca, 'FontSize', 10, 'LineWidth', 1.2);
end

% Print summary
fprintf('\n===== Summary =====\n');
fprintf('Baseline window: %.2f to %.2f s\n', baseline_start, baseline_end);
fprintf('Event window: %.2f to %.2f s\n', start_time, end_time);
fprintf('Minimum animals per day: %d\n', min_animals_per_day);

for ip = 1:numel(protocols)
    fprintf('\nProtocol %d:\n', protocols(ip));
    st = statsP{ip};
    if isempty(st), continue; end
    
    for g = [0 1]
        gi = g+1;
        if gi > numel(st) || isempty(st(gi)), continue; end
        
        fprintf('  %s: %d days plotted\n', labels{gi}, numel(st(gi).rel));
        if isfield(st(gi), 'n_animals')
            fprintf('    Animals per day: min=%d, max=%d, mean=%.1f\n', ...
                    min(st(gi).n_animals), max(st(gi).n_animals), mean(st(gi).n_animals));
        end
    end
end

%% Big Stim Protocol Analysis


% The padding works good for all the big stim protocols

% How does the mPFC looks like for animals that went through big stim
% protocol? compare pre-big stim activity to small stim vs post 

% similarly examine whether the mPFC activity is specific to small or big
% stim post-learning








% only using n components
n_components=200;
n_components_kernel= 100;

% make protocol index (n all days x workflow number ordered)
workflow_animal = cellfun(@(x) {x.workflow},{behaviour_data.recording_day},'uni',false);
workflow_cat = grp2idx(horzcat(workflow_animal{:}));

% Create a logical learning index variable (n all days x [0,1])
learning_index_animal = vertcat(combined_sig_day_all_protocols{:});

% Creates an animal index (n all days x animal number ordered)
widefield_animal_idx = grp2idx(cell2mat(cellfun(@(animal,wf) repmat(animal,length(wf),1), ...
    {behaviour_data.animal_id},{passive_data.widefield},'uni',false)'));

big_right_stim_v_stacked= ha.helper_func.pad_widefield_variable(widefield_cat, 'right_big_stim_aligned_V');




% pre post of workflow 3 (right move)
pre = nanmean(right_stim_v_stacked_data(:,:,workflow_cat==5 & learning_index_animal==0 & widefield_animal_idx==6),3);
post = nanmean(right_stim_v_stacked_data(:,:,workflow_cat==5 & learning_index_animal==1 & widefield_animal_idx==6),3);

added_time_Kernel=  fliplr((-10:30)/30);

baseline_time_windows= [-0.1,0];
baseline_mask = (added_time >= baseline_time_windows(1)) & (added_time <= baseline_time_windows(2));


% substract baseline
pre_baseline_sub= pre- mean(pre(:,baseline_mask),2);
post_baseline_sub= post- mean(post(:,baseline_mask),2);

ap.imscroll([plab.wf.svd2px(wf_U(:,:,1:n_components),pre_baseline_sub),plab.wf.svd2px(wf_U(:,:,1:n_components),post_baseline_sub)],added_time);
clim([-max(abs(clim)), max(abs(clim))]);
colormap(ap.colormap( ...
    'PWG'));
axis image;







%% Habituation Analysis

% Load and rename the habituation data
passive_data_string= 'passive_data';
passive_habituation_data = load("C:\Users\havgana\Desktop\DPhil\packaged_data\passive_habituation_data_all_animals_29_01.mat",passive_data_string);  % Function output form of LOAD
passive_habituation_data = passive_habituation_data.(passive_data_string);

added_time_Kernel= fliplr((-10:30)/30); % kernel added time

% Create logical indecies for habituation
animal_list = {'DS017','HA005','HA006','HA007','HA008','HA009','HA010','HA011','HA012','HA013','HA014','HA015','AP030','AP031','AP032'};

% Creates an animal index (n all days x animal number ordered)
widefield_animal_habituation_idx = grp2idx(cell2mat(cellfun(@(animal,wf) repmat(animal,length(wf),1), ...
    animal_list,{passive_habituation_data.widefield},'uni',false)'));

% define mPFC- or non-learners
group_animals = {'DS017','HA006','HA007','HA009','HA013','HA014','HA015','AP030','AP031','AP032'};

% Map indices back to animal names and check membership
is_group_animal_habituation = ismember(animal_list(widefield_animal_habituation_idx), group_animals)';

habituation_data_stacked = cat(2, passive_habituation_data.widefield); % stack 
habituation_center_stim_v_stacked_data = ha.helper_func.pad_widefield_variable(habituation_data_stacked, 'center_stim_aligned_V'); % pad just to align to V xT x Days
habituation_center_stim_kernel= ha.helper_func.pad_widefield_variable(habituation_data_stacked, 'center_stim_aligned_kernel');

%% Plot Individual Animal CCF Max Activity for V for Habituation - Pre learning - Post learning 


% Define protocol to analyze
protocol_idx = 1; % Change as needed

% Define time windows
event_times = [0, 0.35];
baseline_time_windows = [-0.1, 0];

% Create masks
event_time_window_mask = (added_time >= event_times(1)) & (added_time <= event_times(2));
baseline_mask = (added_time >= baseline_time_windows(1)) & (added_time <= baseline_time_windows(2));

% Define data source for main protocols
data_to_plot = center_stim_v_stacked_data; % Change as needed

% Loop through each animal
for animal_idx = 1:length(animal_list)
    
    % HABITUATION
    hab_mask = widefield_animal_habituation_idx == animal_idx;
    
    if ~any(hab_mask)
        fprintf('No habituation data for animal %s\n', animal_list{animal_idx});
        continue;
    end
    
    hab_avg = nanmean(habituation_center_stim_v_stacked_data(:, :, hab_mask), 3);
    hab_baseline_sub = hab_avg - mean(hab_avg(:, baseline_mask), 2);
    hab_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), hab_baseline_sub(:, event_time_window_mask));
    hab_max = max(hab_px, [], 3);
    n_hab_days = sum(hab_mask);
    
    % PRE-LEARNING
    pre_mask = (widefield_animal_idx == animal_idx) & (workflow_cat == protocol_idx) & (learning_index_animal == 0);
    
    if ~any(pre_mask)
        fprintf('No pre-learning data for animal %s\n', animal_list{animal_idx});
        continue;
    end
    
    pre_avg = nanmean(data_to_plot(:, :, pre_mask), 3);
    pre_baseline_sub = pre_avg - mean(pre_avg(:, baseline_mask), 2);
    pre_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), pre_baseline_sub(:, event_time_window_mask));
    pre_max = max(pre_px, [], 3);
    n_pre_days = sum(pre_mask);
    
    % POST-LEARNING
    post_mask = (widefield_animal_idx == animal_idx) & (workflow_cat == protocol_idx) & (learning_index_animal == 1);
    
    if ~any(post_mask)
        fprintf('No post-learning data for animal %s\n', animal_list{animal_idx});
    end
    
    post_avg = nanmean(data_to_plot(:, :, post_mask), 3);
    post_baseline_sub = post_avg - mean(post_avg(:, baseline_mask), 2);
    post_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), post_baseline_sub(:, event_time_window_mask));
    post_max = max(post_px, [], 3);
    n_post_days = sum(post_mask);
    
    % COMPUTE COLOR LIMIT
    all_vals = [hab_px(:); pre_px(:); post_px(:)];
    clim_val = 0.5 * max(abs(all_vals));
    
    % PLOT
    figure('Position', [100, 100, 1500, 400]);
    
    % Habituation
    subplot(1, 3, 1);
    imagesc(hab_max);
    axis image off;
    colormap(ap.colormap('PWG'));
    clim([-clim_val, clim_val]);
    title(sprintf('Habituation (n=%d days)', n_hab_days), 'FontSize', 12, 'FontWeight', 'bold');
    ap.wf_draw('ccf');
    
    % Pre-learning
    subplot(1, 3, 2);
    imagesc(pre_max);
    axis image off;
    colormap(ap.colormap('PWG'));
    clim([-clim_val, clim_val]);
    title(sprintf('Pre-Learning (n=%d days)', n_pre_days), 'FontSize', 12, 'FontWeight', 'bold');
    ap.wf_draw('ccf');
    
    % Post-learning
    subplot(1, 3, 3);
    imagesc(post_max);
    axis image off;
    colormap(ap.colormap('PWG'));
    clim([-clim_val, clim_val]);
    title(sprintf('Post-Learning (n=%d days)', n_post_days), 'FontSize', 12, 'FontWeight', 'bold');
    ap.wf_draw('ccf');
    
    % Overall title
    sgtitle(sprintf('Animal %s - Max Activity (%.0f-%.0fms)', ...
            animal_list{animal_idx}, event_times(1)*1000, event_times(2)*1000), ...
            'FontSize', 14, 'FontWeight', 'bold');
    
    % Add colorbar
    colorbar('Position', [0.92, 0.3, 0.015, 0.4]);
end

%% Plot Group Averages 


% Define protocol to analyze
protocol_idx = 1;

% Define time windows
event_times = [0, 0.35];
baseline_time_windows = [-0.1, 0];


% Create masks
event_time_window_mask = (added_time_Kernel >= event_times(1)) & (added_time_Kernel <= event_times(2));
baseline_mask = (added_time_Kernel >= baseline_time_windows(1)) & (added_time_Kernel <= baseline_time_windows(2));

% Define data source
data_to_plot = center_stim_kernel;
habituation_data= habituation_center_stim_kernel;

% ===== COMPUTE GROUP AVERAGES =====

% mPFC+ (Learners)
hab_learner = nanmean(habituation_data(:, :, is_group_animal_habituation == 0), 3);
pre_learner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 0) & (is_group_animal == 0)), 3);
post_learner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 1) & (is_group_animal == 0)), 3);

% mPFC- (Non-learners)
hab_nonlearner = nanmean(habituation_data(:, :, is_group_animal_habituation == 1), 3);
pre_nonlearner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 0) & (is_group_animal == 1)), 3);
post_nonlearner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 1) & (is_group_animal == 1)), 3);

% ===== BASELINE SUBTRACT =====

% mPFC+
hab_learner_baseline_sub = hab_learner - mean(hab_learner(:, baseline_mask), 2);
pre_learner_baseline_sub = pre_learner - mean(pre_learner(:, baseline_mask), 2);
post_learner_baseline_sub = post_learner - mean(post_learner(:, baseline_mask), 2);

% mPFC-
hab_nonlearner_baseline_sub = hab_nonlearner - mean(hab_nonlearner(:, baseline_mask), 2);
pre_nonlearner_baseline_sub = pre_nonlearner - mean(pre_nonlearner(:, baseline_mask), 2);
post_nonlearner_baseline_sub = post_nonlearner - mean(post_nonlearner(:, baseline_mask), 2);

% ===== CONVERT TO PIXEL SPACE =====

% mPFC+
hab_learner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), hab_learner_baseline_sub(:, event_time_window_mask));
pre_learner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), pre_learner_baseline_sub(:, event_time_window_mask));
post_learner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), post_learner_baseline_sub(:, event_time_window_mask));

% mPFC-
hab_nonlearner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), hab_nonlearner_baseline_sub(:, event_time_window_mask));
pre_nonlearner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), pre_nonlearner_baseline_sub(:, event_time_window_mask));
post_nonlearner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), post_nonlearner_baseline_sub(:, event_time_window_mask));

% ===== MAX PROJECTION =====

% mPFC+
hab_learner_max = max(hab_learner_px, [], 3);
pre_learner_max = max(pre_learner_px, [], 3);
post_learner_max = max(post_learner_px, [], 3);

% mPFC-
hab_nonlearner_max = max(hab_nonlearner_px, [], 3);
pre_nonlearner_max = max(pre_nonlearner_px, [], 3);
post_nonlearner_max = max(post_nonlearner_px, [], 3);

% ===== COMPUTE GLOBAL COLOR LIMIT =====

all_vals = [hab_learner_px(:); pre_learner_px(:); post_learner_px(:); ...
            hab_nonlearner_px(:); pre_nonlearner_px(:); post_nonlearner_px(:)];
clim_val = 0.5 * max(abs(all_vals));

% ===== PLOT =====

figure('Position', [100, 100, 1500, 800]);

% Row 1: mPFC+ (Learners)
% Habituation
subplot(2, 3, 1);
imagesc(hab_learner_max);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title('mPFC+ Habituation', 'FontSize', 12, 'FontWeight', 'bold', 'Color', cmPFC_plus );
ap.wf_draw('ccf');

% Pre-learning
subplot(2, 3, 2);
imagesc(pre_learner_max);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title('mPFC+ Pre-Learning', 'FontSize', 12, 'FontWeight', 'bold', 'Color', cmPFC_plus);
ap.wf_draw('ccf');

% Post-learning
subplot(2, 3, 3);
imagesc(post_learner_max);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title('mPFC+ Post-Learning', 'FontSize', 12, 'FontWeight', 'bold', 'Color', cmPFC_plus);
ap.wf_draw('ccf');

% Row 2: mPFC- (Non-learners)
% Habituation
subplot(2, 3, 4);
imagesc(hab_nonlearner_max);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title('mPFC- Habituation', 'FontSize', 12, 'FontWeight', 'bold', 'Color', cmPFC_minus);
ap.wf_draw('ccf');

% Pre-learning
subplot(2, 3, 5);
imagesc(pre_nonlearner_max);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title('mPFC- Pre-Learning', 'FontSize', 12, 'FontWeight', 'bold', 'Color', cmPFC_minus);
ap.wf_draw('ccf');

% Post-learning
subplot(2, 3, 6);
imagesc(post_nonlearner_max);
axis image off;
colormap(ap.colormap('PWG'));
clim([-clim_val, clim_val]);
title('mPFC- Post-Learning', 'FontSize', 12, 'FontWeight', 'bold', 'Color', cmPFC_minus);
ap.wf_draw('ccf');

% Overall title
sgtitle(sprintf('Group Averages: Max Activity (%.0f-%.0fms)', ...
        event_times(1)*1000, event_times(2)*1000), ...
        'FontSize', 14, 'FontWeight', 'bold');

% Add colorbar
colorbar('Position', [0.92, 0.3, 0.015, 0.4]);


%%

%% ===== GROUP CCF VIDEOS: HABITUATION - PRE - POST =====

% Define protocol to analyze
protocol_idx = 1;

% Define baseline window
baseline_time_windows = [-0.1, 0];
baseline_mask = (added_time_Kernel >= baseline_time_windows(1)) & (added_time_Kernel <= baseline_time_windows(2));

% Define data source
data_to_plot = center_stim_kernel;
habituation_data= habituation_center_stim_kernel;


% ===== mPFC+ (Learners) =====

% Habituation
hab_learner = nanmean(habituation_data(:, :, is_group_habituation == 0), 3);
hab_learner_baseline_sub = hab_learner - mean(hab_learner(:, baseline_mask), 2);
hab_learner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), hab_learner_baseline_sub);

% Pre-learning
pre_learner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 0) & (is_group_animal == 0)), 3);
pre_learner_baseline_sub = pre_learner - mean(pre_learner(:, baseline_mask), 2);
pre_learner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), pre_learner_baseline_sub);

% Post-learning
post_learner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 1) & (is_group_animal == 0)), 3);
post_learner_baseline_sub = post_learner - mean(post_learner(:, baseline_mask), 2);
post_learner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), post_learner_baseline_sub);

% Stack as 4D: X × Y × Time × Condition
learner_4D = cat(4, hab_learner_px, pre_learner_px, post_learner_px);

%% ===== mPFC- (Non-learners) =====

% Habituation
hab_nonlearner = nanmean(habituation_kernel(:, :, is_group_habituation == 1), 3);
hab_nonlearner_baseline_sub = hab_nonlearner - mean(hab_nonlearner(:, baseline_mask), 2);
hab_nonlearner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), hab_nonlearner_baseline_sub);

% Pre-learning
pre_nonlearner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 0) & (is_group_animal == 1)), 3);
pre_nonlearner_baseline_sub = pre_nonlearner - mean(pre_nonlearner(:, baseline_mask), 2);
pre_nonlearner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), pre_nonlearner_baseline_sub);

% Post-learning
post_nonlearner = nanmean(data_to_plot(:, :, (workflow_cat == protocol_idx) & (learning_index_animal == 1) & (is_group_animal == 1)), 3);
post_nonlearner_baseline_sub = post_nonlearner - mean(post_nonlearner(:, baseline_mask), 2);
post_nonlearner_px = plab.wf.svd2px(wf_U(:, :, 1:n_components), post_nonlearner_baseline_sub);

% Stack as 4D: X × Y × Time × Condition
nonlearner_4D = cat(4, hab_nonlearner_px, pre_nonlearner_px, post_nonlearner_px);

%% ===== COMPUTE GLOBAL COLOR LIMIT =====

all_vals = [learner_4D(:); nonlearner_4D(:)];
clim_val = max(abs(all_vals));

%% ===== PLOT mPFC+ =====

figure('Name', 'mPFC+ Group');
ap.imscroll(learner_4D, added_time_Kernel);
clim([-clim_val, clim_val]);
colormap(ap.colormap('PWG'));
axis image;
title('mPFC+ Group: Habituation → Pre-Learning → Post-Learning');
ap.wf_draw('ccf');

%% ===== PLOT mPFC- =====

figure('Name', 'mPFC- Group');
ap.imscroll(nonlearner_4D, added_time_Kernel);
clim([-clim_val, clim_val]);
colormap(ap.colormap('PWG'));
axis image;
title('mPFC- Group: Habituation → Pre-Learning → Post-Learning');
ap.wf_draw('ccf');

fprintf('\n===== CCF Videos Created =====\n');
fprintf('Use slider to navigate through:\n');
fprintf('  Condition 1: Habituation\n');
fprintf('  Condition 2: Pre-Learning\n');
fprintf('  Condition 3: Post-Learning\n');
%% Do CCF videos of averages

% Average across all days for this animal
center_stim_activity = nanmean(center_stim_kernel(:, :,is_group_animal==1), 3);

% Subtract baseline
center_stim_activity_baseline_sub = center_stim_activity - mean(center_stim_activity(:, baseline_mask), 2);

% Plot
ap.imscroll(plab.wf.svd2px(wf_U(:, :, 1:n_components), center_stim_activity_baseline_sub), added_time_Kernel);
clim([-max(abs(clim)), max(abs(clim))]);
colormap(ap.colormap('PWG'));
axis image;
title(sprintf('mPFC+ group'));

%% Plot individual animal CCF videos averaged for all habituation days


added_time_Kernel=  fliplr((-10:30)/30);

baseline_time_windows = [-0.1, 0];
baseline_mask = (added_time_Kernel >= baseline_time_windows(1)) & (added_time_Kernel <= baseline_time_windows(2));

% Loop through each animal
for animal_idx = 1:length(animal_list)
    % Average across all days for this animal
    center_stim_activity = nanmean(center_stim_v_stacked_data(:, :, widefield_animal_idx == animal_idx), 3);
    
    % Subtract baseline
    center_stim_activity_baseline_sub = center_stim_activity - mean(center_stim_activity(:, baseline_mask), 2);
    
    % Plot
    ap.imscroll(plab.wf.svd2px(wf_U(:, :, 1:n_components), center_stim_activity_baseline_sub), added_time);
    clim([-max(abs(clim)), max(abs(clim))]);
    colormap(ap.colormap('PWG'));
    axis image;
    title(sprintf('Animal %s', animal_list{animal_idx}));
end

%% Plot mPFC+/ mPFC- seperated CCF videos

% animals that have not learned the static but learned the right
group_animals = {'DS017','HA006','HA007','HA009','HA013','HA014','HA015','AP030','AP031','AP032'};

% Create a list of animal IDs repeated per recording day
animal_ids_all_days = cellfun(@(animal, wf) repmat({animal}, length(wf), 1), ...
    animal_list, {passive_data.widefield}, 'UniformOutput', false);

% Convert to column vector
animal_ids_all_days_stacked = vertcat(animal_ids_all_days{:});

% Create a logical index for whether each row belongs to the group
is_group_animal = ismember(animal_ids_all_days_stacked, group_animals);  % (n_days_all x 1)





%% 

% load the passive data for the behaviour
% create the indecies as before
% plot individual animal CCF activity habituation - pre-post 


%% Archived

%% Filter our big stim protocols
% Provides an option to set whether to filter out post-big regular sized
% static or to keep them just removing big stim days

% ----------------- CONFIG -----------------
opts.protocol_list = { ...
  'visual_operant_lick_two_stim_right_move', ...
  'visual_operant_lick_two_stim_static', ...
  'visual_operant_lick_two_stim_right_move_big_stim', ...
  'visual_operant_lick_two_stim_static_big_stim', ...
  'stim_wheel*' ...
};

opts.big_names = { ...
  'visual_operant_lick_two_stim_right_move_big_stim', ...
  'visual_operant_lick_two_stim_static_big_stim' ...
};

% protocols to drop AFTER the first big_stim, if drop_following=true
opts.following_names = { 'visual_operant_lick_two_stim_static' };
% opts.following_names = { 'stim_wheel*' }; % For HA014 for now

opts.drop_following   = false;   % <--- true if to drop following ; false otherwise
opts.error_on_unknown = true;   % error if a workflow isn't in protocol_list

% ------------------------------------------

animal_list = {behaviour_data.animal_id};

for animal_idx = 1:numel(animal_list)
    rd = behaviour_data(animal_idx).recording_day;
    wf = passive_data(animal_idx).widefield;   % optional, if present

    [keptLocalIdx] = ha.helper_func.select_sessions_by_protocol(rd, opts);

    if isempty(keptLocalIdx)
        fprintf('Animal %s: nothing kept (had %d sessions)\n', ...
            animal_list{animal_idx}, numel(rd));
        continue
    end

    % apply to both structures (keep them in sync)
    behaviour_data(animal_idx).recording_day = rd(keptLocalIdx);
    if numel(wf) == numel(rd)
        passive_data(animal_idx).widefield = wf(keptLocalIdx);
    else
        warning('Animal %s: widefield length %d != recording_day length %d. Skipping WF filter.', ...
            animal_list{animal_idx}, numel(wf), numel(rd));
    end

    fprintf('\nAnimal %s: kept %d/%d sessions', ...
        animal_list{animal_idx}, numel(keptLocalIdx), numel(rd));
end
